{ "shader":[ {"@rid":"41:0", "@class":"shader"
, "name":"Primitives example"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Thu Jan 12 00:57:48 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0, abs(l), (l > 0.0) ? pow(max(0.0, h), m) : 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight), dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((u_lightColor * (diffuseColor * litR.y + u_specular * litR.z * u_specularFactor)).rgb, diffuseColor.a);\r\n  \r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Thu Jan 12 00:58:14 MST 2017 by glenn */\r\n  \"use strict\";\r\n\r\n\r\n\ttwgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createPlaneBufferInfo(gl, 2, 2),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n      twgl.primitives.createCresentBufferInfo(gl, 1, 1, 0.5, 0.1, 24),\r\n      twgl.primitives.createCylinderBufferInfo(gl, 1, 2, 24, 2),\r\n      twgl.primitives.createDiscBufferInfo(gl, 1, 24),\r\n      twgl.primitives.createTorusBufferInfo(gl, 1, 0.4, 24, 12),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [1, 4, -30];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Checker textured primitives floating around\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:2", "@class":"shader"
, "name":"ncolor shader"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"precision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,  abs(l),  (l > 0.0) ? pow(max(0.0, h), m) : 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec3 normal = normalize(v_normal);\r\n  vec4 diffuseColor = vec4(normal * 0.5 + 0.5, 1);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(normal, surfaceToLight),\r\n                    dot(normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Thu Jan 12 00:58:14 MST 2017 by glenn */\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createPlaneBufferInfo(gl, 2, 2),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n      twgl.primitives.createCresentBufferInfo(gl, 1, 1, 0.5, 0.1, 24),\r\n      twgl.primitives.createCylinderBufferInfo(gl, 1, 2, 24, 2),\r\n      twgl.primitives.createDiscBufferInfo(gl, 1, 24),\r\n      twgl.primitives.createTorusBufferInfo(gl, 1, 0.4, 24, 12),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [1, 4, -30];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Dynamic colored primitives\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:4", "@class":"shader"
, "name":"kaleid shader"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec4 a_position;\r\n    attribute vec2 a_id;\r\n    varying vec2 v_texcoord;\r\n    uniform mat4 u_matrix;\r\n    uniform mat4 u_projection;\r\n    uniform float u_angleTime;\r\n    uniform float u_angleScale;\r\n    void main() {\r\n      vec4 localPosition = u_matrix * a_position;\r\n      float angle = a_id.x * u_angleScale + u_angleTime;\r\n      float radius = localPosition.y;\r\n      float c = cos(angle);\r\n      float s = sin(angle);\r\n      mat4 m = mat4(\r\n          vec4(c, s, 0, 0),\r\n          vec4(-s, c, 0, 0),\r\n          vec4(0, 0, 1, 0),\r\n          vec4(0, 0, 0, 1));\r\n      gl_Position = u_projection * m * localPosition;\r\n      v_texcoord = a_position.xy * 0.5 + 0.5;\r\n    }"
 ,"fragmentScript":"/* Fragment Shader Fri Jan 13 21:25:42 MST 2017 by admin*/\r\n  precision mediump float;\r\n\r\n    varying vec2 v_texcoord;\r\n    uniform sampler2D u_texture;\r\n\r\n    void main() {\r\n      gl_FragColor = texture2D(u_texture, v_texcoord);\r\n    }"
 ,"testScript":"/* Shader Test Fri Jan 13 21:25:42 MST 2017 by admin*/"
 ,"description":"used by Kaleidoscope"
 ,"usesShader": {} }, 
{"@rid":"41:5", "@class":"shader"
, "name":"Kaleidoscope"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Fri Jan 13 21:26:44 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_ambient;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\nuniform float u_fogNear;\r\nuniform float u_fogFar;\r\nuniform vec4 u_fogColor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              abs(l),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\r\n  float fogFactor = smoothstep(u_fogNear, u_fogFar, depth);\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = mix(outColor, u_fogColor, fogFactor);\r\n}"
 ,"testScript":"/* Shader Test Fri Jan 13 21:26:44 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n    var kaleidProgramInfo = twgl.createProgramInfo(gl, [\"kaleid-vs\", \"kaleid-fs\"]);\r\n\r\n    function createUnitQuadsBufferInfo(gl, across, down) {\r\n      var numQuads    = across * down;\r\n      var numVertices = 4 * numQuads;\r\n      var numIndices  = 6 * numQuads;\r\n\r\n      var positions = twgl.primitives.createAugmentedTypedArray(3, numVertices);\r\n      var ids       = twgl.primitives.createAugmentedTypedArray(2, numVertices, Uint16Array);\r\n      var indices   = twgl.primitives.createAugmentedTypedArray(3, numIndices, Uint16Array);\r\n\r\n      var verts = [\r\n        -1, -1, -1,\r\n         1, -1,  0,\r\n        -1,  1,  0,\r\n         1,  1,  1,\r\n      ];\r\n\r\n      var ndx = 0;\r\n      for (var yy = 0; yy < down; ++yy) {\r\n        for (var xx = 0; xx < across; ++xx) {\r\n          positions.push(verts);\r\n          ids.push(xx, yy, xx, yy, xx, yy, xx, yy);\r\n          indices.push(ndx + 0, ndx + 1, ndx + 2, ndx + 2, ndx + 1, ndx + 3);\r\n          ndx += 4;\r\n        }\r\n      }\r\n\r\n      return twgl.createBufferInfoFromArrays(gl, {\r\n        position: positions,\r\n        id: ids,\r\n        indices: indices,\r\n      });\r\n    }\r\n\r\n\r\n    var segments = 20;\r\n    var cyAcross = 12;\r\n    var cyDown = 25;\r\n    var bufferInfo = twgl.primitives.createCubeBufferInfo(gl, 2);\r\n    var screenBufferInfo = createUnitQuadsBufferInfo(gl, segments, 1);\r\n\r\n    var fbSize = 1024;\r\n    var framebufferInfo = twgl.createFramebufferInfo(gl, undefined, fbSize, fbSize);\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var uniforms = {\r\n      u_lightWorldPos: [1, 8, -10],\r\n      u_lightColor: [0.2, 0.5, 1.0, 1],\r\n      u_ambient: [0, 0, 0, 1],\r\n      u_specular: [1, 1, 1, 1],\r\n      u_shininess: 50,\r\n      u_specularFactor: 1,\r\n      u_diffuse: tex,\r\n      u_fogColor: [1, 1, 1, 1],\r\n      u_fogNear: 5,\r\n      u_fogFar: 25,\r\n      u_world: m4.identity(),\r\n    };\r\n\r\n    var screenUniforms = {\r\n      u_texture: framebufferInfo.attachments[0],\r\n      u_matrix: m4.translation([1, 1, 0]),\r\n      u_projection: m4.identity(),\r\n      u_angleTime: 0,\r\n      u_angleScale: 1,\r\n    };\r\n\r\n    function lerp(a, b, t) {\r\n      return a + (b - a) * t;\r\n    }\r\n\r\n    var useFramebuffer = true;\r\n\r\n    function switchMode() {\r\n      useFramebuffer = !useFramebuffer;\r\n    }\r\n\r\n    window.addEventListener('keypress', switchMode, false);\r\n    window.addEventListener('click', switchMode, false);\r\n    window.addEventListener('touchstart', switchMode, false);\r\n\r\n    var currentBaseColor;\r\n    var targetBaseColor;\r\n    var baseColorScale;\r\n    var colorFadeDuration = 5;\r\n    var colorChangeDuration = 10;\r\n    var colorFadeTimer;\r\n    var colorChangeTimer;\r\n\r\n    function pickNewColor() {\r\n      currentBaseColor = targetBaseColor || chroma.hsv(Math.random() * 360, 1, 1);\r\n      targetBaseColor = chroma.hsv(Math.random() * 360, 1, 1);\r\n      baseColorScale = chroma.scale([currentBaseColor, targetBaseColor]).mode('lab');\r\n      colorFadeTimer = colorFadeDuration;\r\n      colorChangeTimer = colorChangeDuration;\r\n    }\r\n    pickNewColor();\r\n\r\n    var then = 0;\r\n    function render(time) {\r\n      time *= 0.001;\r\n      var deltaTime = time - then;\r\n      then = time;\r\n\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n\r\n      var aspect;\r\n      if (useFramebuffer) {\r\n        twgl.bindFramebufferInfo(gl, framebufferInfo);\r\n        aspect = 1;\r\n      } else {\r\n        twgl.bindFramebufferInfo(gl, null);\r\n        aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      }\r\n\r\n      colorFadeTimer -= deltaTime;\r\n      colorChangeTimer -= deltaTime;\r\n      if (colorChangeTimer <= 0) {\r\n        pickNewColor();\r\n      }\r\n\r\n      var colorLerp = 1 - Math.max(0, colorFadeTimer / colorFadeDuration);\r\n      var fadeColor = baseColorScale(colorLerp);\r\n      uniforms.u_fogColor = fadeColor.gl();\r\n      var fc = uniforms.u_fogColor;\r\n\r\n      gl.cullFace(gl.BACK);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clearColor(fc[0], fc[1], fc[2], fc[3]);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, aspect, 0.5, 30);\r\n      var eye = [1, 0, -16];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      var camera = m4.lookAt(eye, target, up);\r\n      var view = m4.inverse(camera);\r\n      var viewProjection = m4.multiply(projection, view);\r\n      uniforms.u_viewInverse = camera;\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      for (var ii = 0; ii < 25; ++ii) {\r\n        var x = ii % 5;\r\n        var y = ii / 5 | 0;\r\n        var world = uniforms.u_world;\r\n        m4.identity(world);\r\n        m4.translate(world, [0, 0, 0], world);\r\n        m4.rotateY(world, time * 0.43, world);\r\n        m4.rotateZ(world, time * 0.37, world);\r\n        m4.translate(world, [x * 3 - 7 - 3, y * 3 - 5 - 3, 0], world);\r\n        m4.rotateX(world, time * 0.21 + ii, world);\r\n        m4.rotateY(world, time * 0.53 + ii, world);\r\n\r\n        uniforms.u_world = world;\r\n        uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(world));\r\n        uniforms.u_worldViewProjection = m4.multiply(viewProjection, world);\r\n//        uniforms.u_lightColor[0] = x / 4;\r\n//        uniforms.u_lightColor[1] = y / 4;\r\n//        uniforms.u_lightColor[2] = 1 - (x + y) / 8;\r\n\r\n//        uniforms.u_lightColor[0] = Math.max(x, y) / 5;\r\n//        uniforms.u_lightColor[1] = Math.max(y, x) / 5;\r\n//        uniforms.u_lightColor[2] = 1;// - (x + y) / 8;\r\n        uniforms.u_lightColor = [2, 2, 2, 1];\r\n\r\n        twgl.setUniforms(programInfo, uniforms);\r\n        twgl.drawBufferInfo(gl, bufferInfo);\r\n      }\r\n\r\n      if (useFramebuffer) {\r\n        twgl.bindFramebufferInfo(gl, null);\r\n\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(kaleidProgramInfo.program);\r\n\r\n        var maxScale = Math.PI * 2 / 6;\r\n        var minScale = Math.PI * 2 / segments;\r\n        var s = 0.7;\r\n        aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        m4.ortho(-aspect * s, aspect * s, -1 * s, 1 * s, -1, 1, screenUniforms.u_projection);\r\n        screenUniforms.u_angleTime = time * 0.1;\r\n        screenUniforms.u_angleScale = lerp(minScale, maxScale, Math.sin(time * 0.017) * 0.5 + 0.5);\r\n        m4.identity(screenUniforms.u_matrix);\r\n        m4.translate(screenUniforms.u_matrix, [1, 0.5, 0], screenUniforms.u_matrix);\r\n        m4.scale(screenUniforms.u_matrix, [1, 2, 1], screenUniforms.u_matrix);\r\n\r\n        twgl.setBuffersAndAttributes(gl, kaleidProgramInfo, screenBufferInfo);\r\n        twgl.setUniforms(kaleidProgramInfo, screenUniforms);\r\n        twgl.drawBufferInfo(gl, screenBufferInfo);\r\n      }\r\n\r\n      //requestAnimationFrame(render);\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"adapted from https://twgljs.org/ example"
 ,"usesShader": {"kaleid": {"@rid":"41:4", "@class":"shader"
, "name":"kaleid shader"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec4 a_position;\r\n    attribute vec2 a_id;\r\n    varying vec2 v_texcoord;\r\n    uniform mat4 u_matrix;\r\n    uniform mat4 u_projection;\r\n    uniform float u_angleTime;\r\n    uniform float u_angleScale;\r\n    void main() {\r\n      vec4 localPosition = u_matrix * a_position;\r\n      float angle = a_id.x * u_angleScale + u_angleTime;\r\n      float radius = localPosition.y;\r\n      float c = cos(angle);\r\n      float s = sin(angle);\r\n      mat4 m = mat4(\r\n          vec4(c, s, 0, 0),\r\n          vec4(-s, c, 0, 0),\r\n          vec4(0, 0, 1, 0),\r\n          vec4(0, 0, 0, 1));\r\n      gl_Position = u_projection * m * localPosition;\r\n      v_texcoord = a_position.xy * 0.5 + 0.5;\r\n    }"
 ,"fragmentScript":"/* Fragment Shader Fri Jan 13 21:25:42 MST 2017 by admin*/\r\n  precision mediump float;\r\n\r\n    varying vec2 v_texcoord;\r\n    uniform sampler2D u_texture;\r\n\r\n    void main() {\r\n      gl_FragColor = texture2D(u_texture, v_texcoord);\r\n    }"
 ,"testScript":"/* Shader Test Fri Jan 13 21:25:42 MST 2017 by admin*/"
 ,"description":"used by Kaleidoscope"
 ,"usesShader": {} }} }, 
{"@rid":"41:6", "@class":"shader"
, "name":"Zoom"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 03:16:20 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              abs(l),//max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 03:16:20 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var v3 = twgl.v3;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    function easeInOut(t, start, end) {\r\n      var c = end - start;\r\n      if ((t /= 0.5) < 1) {\r\n        return c / 2 * t * t + start;\r\n      } else {\r\n        return -c / 2 * ((--t) * (t - 2) - 1) + start;\r\n      }\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n    var targetNdx = 0;\r\n    var targetTimer = 0;\r\n    var zoomTimer = 0;\r\n    var eye = v3.copy([1, 4, -60]);\r\n    var target = v3.copy([0, 0, 0]);\r\n    var up = [0, 1, 0];\r\n    var zoomScale = 1.4;\r\n    var zoomDuration = 2;\r\n    var targetChangeInterval = 3;\r\n    var oldEye;\r\n    var oldTarget;\r\n    var newEye;\r\n    var newTarget;\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-50, 50), rand(-50, 50), rand(-50, 50)],\r\n        scale: rand(1, 5),\r\n        size: 2,\r\n        xSpeed: rand(0.2, 0.7),\r\n        zSpeed: rand(0.2, 0.7),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    var then = 0;\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      var elapsed = time - then;\r\n      then = time;\r\n\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var fovy = 30 * Math.PI / 180;\r\n      var projection = m4.perspective(fovy, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 200);\r\n\r\n      targetTimer -= elapsed;\r\n      if (targetTimer <= 0) {\r\n        targetTimer = targetChangeInterval;\r\n        zoomTimer = 0;\r\n        targetNdx = (targetNdx + 1) % objects.length;\r\n        oldEye = v3.copy(eye);\r\n        oldTarget = v3.copy(target);\r\n        var targetObj = objects[targetNdx];\r\n        newTarget = targetObj.translation;\r\n        var halfSize = targetObj.size * targetObj.scale * zoomScale * 0.5;\r\n        var distance = halfSize / Math.tan(fovy * 0.5);\r\n        var direction = v3.normalize(v3.subtract(eye, newTarget));\r\n        newEye = v3.add(newTarget, v3.mulScalar(direction, distance));\r\n      }\r\n\r\n      zoomTimer += elapsed;\r\n      var lerp = easeInOut(Math.min(1, zoomTimer / zoomDuration), 0, 1);\r\n      eye = v3.lerp(oldEye, newEye, lerp);\r\n      target = v3.lerp(oldTarget, newTarget, lerp);\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time * obj.xSpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.scale(world, [obj.scale, obj.scale, obj.scale], world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      requestAnimationFrame(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Zoom around to different objects\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:7", "@class":"shader"
, "name":"Tiny"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec4 position;\r\n\r\nvoid main() {\r\n  gl_Position = position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:12:51 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nuniform vec2 resolution;\r\nuniform float time;\r\n\r\nvoid main() {\r\n  vec2 uv = gl_FragCoord.xy / resolution;\r\n  float color = 0.0;\r\n  // lifted from glslsandbox.com\r\n  color += sin( uv.x * cos( time / 3.0 ) * 60.0 ) + cos( uv.y * cos( time / 2.80 ) * 10.0 );\r\n  color += sin( uv.y * sin( time / 2.0 ) * 40.0 ) + cos( uv.x * sin( time / 1.70 ) * 40.0 );\r\n  color += sin( uv.x * sin( time / 1.0 ) * 10.0 ) + sin( uv.y * sin( time / 3.50 ) * 80.0 );\r\n  color *= sin( time / 10.0 ) * 0.5;\r\n\r\n  gl_FragColor = vec4( vec3( color * 0.5, sin( color + time / 2.5 ) * 0.75, color ), 1.0 );\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:12:51 MST 2017 by admin*/\r\n    \"use strict\";\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var arrays = {\r\n      position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],\r\n    };\r\n    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\r\n\r\n    function render(time) {\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      var uniforms = {\r\n        time: time * 0.001,\r\n        resolution: [gl.canvas.width, gl.canvas.height],\r\n      };\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      twgl.setUniforms(programInfo, uniforms);\r\n      twgl.drawBufferInfo(gl, bufferInfo);\r\n\r\n      requestAnimationFrame(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Smallest, simplest shader\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:8", "@class":"shader"
, "name":"Cube"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:15:05 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_ambient;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:15:05 MST 2017 by admin*/\r\n\"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var arrays = {\r\n      position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],\r\n      normal:   [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],\r\n      texcoord: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],\r\n      indices:  [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],\r\n    };\r\n    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var uniforms = {\r\n      u_lightWorldPos: [1, 8, -10],\r\n      u_lightColor: [1, 0.8, 0.8, 1],\r\n      u_ambient: [0, 0, 0, 1],\r\n      u_specular: [1, 1, 1, 1],\r\n      u_shininess: 50,\r\n      u_specularFactor: 1,\r\n      u_diffuse: tex,\r\n    };\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 10);\r\n      var eye = [1, 4, -6];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      var camera = m4.lookAt(eye, target, up);\r\n      var view = m4.inverse(camera);\r\n      var viewProjection = m4.multiply(projection, view);\r\n      var world = m4.rotationY(time);\r\n\r\n      uniforms.u_viewInverse = camera;\r\n      uniforms.u_world = world;\r\n      uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(world));\r\n      uniforms.u_worldViewProjection = m4.multiply(viewProjection, world);\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      twgl.setUniforms(programInfo, uniforms);\r\n      gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);\r\n\r\n      //requestAnimationFrame(render);\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Rotating Cube\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:9", "@class":"shader"
, "name":"one-point"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\n\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  gl_Position = u_worldViewProjection * a_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:17:57 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\n\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  if (diffuseColor.a < 0.1) {\r\n    discard;\r\n  }\r\n  gl_FragColor = diffuseColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:17:57 MST 2017 by admin*/"
 ,"description":"used by Textures example\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:10", "@class":"shader"
, "name":"env-map"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_world;\r\nuniform mat4 u_worldViewProjection;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\n\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = u_worldViewProjection * a_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:18:44 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nuniform samplerCube u_texture;\r\n\r\nvarying vec3 v_surfaceToView;\r\nvarying vec3 v_normal;\r\n\r\nvoid main() {\r\n  vec3 normal = normalize(v_normal);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec4 color = textureCube(u_texture, -reflect(surfaceToView, normal));\r\n  gl_FragColor = color;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:18:44 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var onePointProgramInfo = twgl.createProgramInfo(gl, [\"one-point-vs\", \"one-point-fs\"]);\r\n    var envMapProgramInfo = twgl.createProgramInfo(gl, [\"env-map-vs\", \"env-map-fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createPlaneBufferInfo(gl, 2, 2),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      if (max === undefined) {\r\n        max = min;\r\n        min = 0;\r\n      }\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var baseHue = rand(360);\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    // A circle on a canvas\r\n    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\r\n    ctx.canvas.width  = 64;\r\n    ctx.canvas.height = 64;\r\n\r\n    function updateCanvas(time) {\r\n      ctx.fillStyle = \"#00f\";\r\n      ctx.strokeStyle = \"#ff0\";\r\n      ctx.lineWidth = \"10\";\r\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n      ctx.beginPath();\r\n      ctx.arc(ctx.canvas.width / 2, ctx.canvas.height / 2, ctx.canvas.width / 2.2 * Math.abs(Math.cos(time)), 0, Math.PI * 2);\r\n      ctx.stroke();\r\n    }\r\n    updateCanvas(0);\r\n\r\n    // A cubemap drawn to a canvas with a circle on each face.\r\n    var cubemapCtx = document.createElement(\"canvas\").getContext(\"2d\");\r\n    var size = 40;\r\n    cubemapCtx.canvas.width  = size * 6;\r\n    cubemapCtx.canvas.height = size;\r\n    cubemapCtx.fillStyle = \"#888\";\r\n    for (var ff = 0; ff < 6; ++ff) {\r\n      var color = chroma.hsv((baseHue + ff * 10) % 360, 1 - ff / 6, 1);\r\n      cubemapCtx.fillStyle = color.darken().hex();\r\n      cubemapCtx.fillRect(size * ff, 0, size, size);\r\n      cubemapCtx.save();\r\n      cubemapCtx.translate(size * (ff + 0.5), size * 0.5);\r\n      cubemapCtx.beginPath();\r\n      cubemapCtx.arc(0, 0, size * 0.3, 0, Math.PI * 2);\r\n      cubemapCtx.fillStyle = color.hex();\r\n      cubemapCtx.fill();\r\n      cubemapCtx.restore();\r\n    }\r\n\r\n    var textures = twgl.createTextures(gl, {\r\n      // a power of 2 image\r\n      hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\r\n      // a non-power of 2 image\r\n      clover: { src: \"images/clover.jpg\" },\r\n      // From a canvas\r\n      fromCanvas: { src: ctx.canvas },\r\n      // A cubemap from 6 images\r\n      yokohama: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        src: [\r\n          'images/yokohama/posx.jpg',\r\n          'images/yokohama/negx.jpg',\r\n          'images/yokohama/posy.jpg',\r\n          'images/yokohama/negy.jpg',\r\n          'images/yokohama/posz.jpg',\r\n          'images/yokohama/negz.jpg',\r\n        ],\r\n      },\r\n      // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\r\n      goldengate: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        src: 'images/goldengate.jpg',\r\n      },\r\n      // A 2x2 pixel texture from a JavaScript array\r\n      checker: {\r\n        mag: gl.NEAREST,\r\n        min: gl.LINEAR,\r\n        src: [\r\n          255, 255, 255, 255,\r\n          192, 192, 192, 255,\r\n          192, 192, 192, 255,\r\n          255, 255, 255, 255,\r\n        ],\r\n      },\r\n      // a 1x8 pixel texture from a typed array.\r\n      stripe: {\r\n        mag: gl.NEAREST,\r\n        min: gl.LINEAR,\r\n        format: gl.LUMINANCE,\r\n        src: new Uint8Array([\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n        ]),\r\n        width: 1,\r\n      },\r\n      // a cubemap from array\r\n      cubemapFromArray: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        format: gl.RGBA,\r\n        src: [\r\n          0xF0, 0x80, 0x80, 0xFF,\r\n          0x80, 0xE0, 0x80, 0xFF,\r\n          0x80, 0x80, 0xD0, 0xFF,\r\n          0xC0, 0x80, 0x80, 0xFF,\r\n          0x80, 0xB0, 0x80, 0xFF,\r\n          0x80, 0x80, 0x00, 0xFF,\r\n        ],\r\n      },\r\n      cubemapFromCanvas: { target: gl.TEXTURE_CUBE_MAP, src: cubemapCtx.canvas },\r\n    });\r\n\r\n    // This is soley to make it easy to pick textures at random\r\n    var twoDTextures = [\r\n      textures.checker,\r\n      textures.stripe,\r\n      textures.hftIcon,\r\n      textures.clover,\r\n      textures.fromCanvas,\r\n    ];\r\n\r\n    var cubeTextures = [\r\n      textures.yokohama,\r\n      textures.goldengate,\r\n      textures.cubemapFromCanvas,\r\n      textures.cubemapFromArray,\r\n    ];\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms;\r\n      var programInfo;\r\n      var shape;\r\n      var renderType = rand(0, 2) | 0;\r\n      switch (renderType) {\r\n        case 0:  // checker\r\n          shape = shapes[ii % shapes.length];\r\n          programInfo = onePointProgramInfo;\r\n          uniforms = {\r\n            u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n            u_diffuse: twoDTextures[rand(0, twoDTextures.length) | 0],\r\n            u_viewInverse: camera,\r\n            u_world: m4.identity(),\r\n            u_worldInverseTranspose: m4.identity(),\r\n            u_worldViewProjection: m4.identity(),\r\n          };\r\n          break;\r\n        case 1:  // yokohama\r\n          shape = rand(0, 2) < 1 ? shapes[1] : shapes[3];\r\n          programInfo = envMapProgramInfo;\r\n          uniforms = {\r\n            u_texture: cubeTextures[rand(0, cubeTextures.length) | 0],\r\n            u_viewInverse: camera,\r\n            u_world: m4.identity(),\r\n            u_worldInverseTranspose: m4.identity(),\r\n            u_worldViewProjection: m4.identity(),\r\n          };\r\n          break;\r\n        default:\r\n          throw \"wAT!\";\r\n      }\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shape,\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.BLEND);\r\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var radius = 20;\r\n      var orbitSpeed = time * 0.1;\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [Math.cos(orbitSpeed) * radius, 4, Math.sin(orbitSpeed) * radius];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      updateCanvas(time);\r\n      twgl.setTextureFromElement(gl, textures.fromCanvas, ctx.canvas);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      requestAnimationFrame(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"used by Textures example\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:11", "@class":"shader"
, "name":"Textures Example"
 ,"vertexScript":"/* Vertex Shader */"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:32:35 MST 2017 by admin*/"
 ,"testScript":"/* Shader Test Sat Jan 14 14:32:35 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var onePointProgramInfo = twgl.createProgramInfo(gl, [\"one-point-vs\", \"one-point-fs\"]);\r\n    var envMapProgramInfo = twgl.createProgramInfo(gl, [\"env-map-vs\", \"env-map-fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createPlaneBufferInfo(gl, 2, 2),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      if (max === undefined) {\r\n        max = min;\r\n        min = 0;\r\n      }\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var baseHue = rand(360);\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    // A circle on a canvas\r\n    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\r\n    ctx.canvas.width  = 64;\r\n    ctx.canvas.height = 64;\r\n\r\n    function updateCanvas(time) {\r\n      ctx.fillStyle = \"#00f\";\r\n      ctx.strokeStyle = \"#ff0\";\r\n      ctx.lineWidth = \"10\";\r\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n      ctx.beginPath();\r\n      ctx.arc(ctx.canvas.width / 2, ctx.canvas.height / 2, ctx.canvas.width / 2.2 * Math.abs(Math.cos(time)), 0, Math.PI * 2);\r\n      ctx.stroke();\r\n    }\r\n    updateCanvas(0);\r\n\r\n    // A cubemap drawn to a canvas with a circle on each face.\r\n    var cubemapCtx = document.createElement(\"canvas\").getContext(\"2d\");\r\n    var size = 40;\r\n    cubemapCtx.canvas.width  = size * 6;\r\n    cubemapCtx.canvas.height = size;\r\n    cubemapCtx.fillStyle = \"#888\";\r\n    for (var ff = 0; ff < 6; ++ff) {\r\n      var color = chroma.hsv((baseHue + ff * 10) % 360, 1 - ff / 6, 1);\r\n      cubemapCtx.fillStyle = color.darken().hex();\r\n      cubemapCtx.fillRect(size * ff, 0, size, size);\r\n      cubemapCtx.save();\r\n      cubemapCtx.translate(size * (ff + 0.5), size * 0.5);\r\n      cubemapCtx.beginPath();\r\n      cubemapCtx.arc(0, 0, size * 0.3, 0, Math.PI * 2);\r\n      cubemapCtx.fillStyle = color.hex();\r\n      cubemapCtx.fill();\r\n      cubemapCtx.restore();\r\n    }\r\n\r\n    var textures = twgl.createTextures(gl, {\r\n      // a power of 2 image\r\n      hftIcon: { src: \"thumbnail?SIZE=FULL&ID=11:284\", mag: gl.NEAREST },\r\n      // a non-power of 2 image\r\n      clover: { src: \"thumbnail?SIZE=FULL&ID=11:282\" },\r\n      // From a canvas\r\n      fromCanvas: { src: ctx.canvas },\r\n      // A cubemap from 6 images\r\n      yokohama: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        src: [\r\n          'thumbnail?SIZE=FULL&ID=11:286',\r\n          'thumbnail?SIZE=FULL&ID=11:288',\r\n          'thumbnail?SIZE=FULL&ID=11:290',\r\n          'thumbnail?SIZE=FULL&ID=11:292',\r\n          'thumbnail?SIZE=FULL&ID=11:294',\r\n          'thumbnail?SIZE=FULL&ID=11:296',\r\n        ],\r\n      },\r\n      // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\r\n      goldengate: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        src: 'thumbnail?SIZE=FULL&ID=11:298',\r\n      },\r\n      // A 2x2 pixel texture from a JavaScript array\r\n      checker: {\r\n        mag: gl.NEAREST,\r\n        min: gl.LINEAR,\r\n        src: [\r\n          255, 255, 255, 255,\r\n          192, 192, 192, 255,\r\n          192, 192, 192, 255,\r\n          255, 255, 255, 255,\r\n        ],\r\n      },\r\n      // a 1x8 pixel texture from a typed array.\r\n      stripe: {\r\n        mag: gl.NEAREST,\r\n        min: gl.LINEAR,\r\n        format: gl.LUMINANCE,\r\n        src: new Uint8Array([\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n        ]),\r\n        width: 1,\r\n      },\r\n      // a cubemap from array\r\n      cubemapFromArray: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        format: gl.RGBA,\r\n        src: [\r\n          0xF0, 0x80, 0x80, 0xFF,\r\n          0x80, 0xE0, 0x80, 0xFF,\r\n          0x80, 0x80, 0xD0, 0xFF,\r\n          0xC0, 0x80, 0x80, 0xFF,\r\n          0x80, 0xB0, 0x80, 0xFF,\r\n          0x80, 0x80, 0x00, 0xFF,\r\n        ],\r\n      },\r\n      cubemapFromCanvas: { target: gl.TEXTURE_CUBE_MAP, src: cubemapCtx.canvas },\r\n    });\r\n\r\n    // This is soley to make it easy to pick textures at random\r\n    var twoDTextures = [\r\n      textures.checker,\r\n      textures.stripe,\r\n      textures.hftIcon,\r\n      textures.clover,\r\n      textures.fromCanvas,\r\n    ];\r\n\r\n    var cubeTextures = [\r\n      textures.yokohama,\r\n      textures.goldengate,\r\n      textures.cubemapFromCanvas,\r\n      textures.cubemapFromArray,\r\n    ];\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms;\r\n      var programInfo;\r\n      var shape;\r\n      var renderType = rand(0, 2) | 0;\r\n      switch (renderType) {\r\n        case 0:  // checker\r\n          shape = shapes[ii % shapes.length];\r\n          programInfo = onePointProgramInfo;\r\n          uniforms = {\r\n            u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n            u_diffuse: twoDTextures[rand(0, twoDTextures.length) | 0],\r\n            u_viewInverse: camera,\r\n            u_world: m4.identity(),\r\n            u_worldInverseTranspose: m4.identity(),\r\n            u_worldViewProjection: m4.identity(),\r\n          };\r\n          break;\r\n        case 1:  // yokohama\r\n          shape = rand(0, 2) < 1 ? shapes[1] : shapes[3];\r\n          programInfo = envMapProgramInfo;\r\n          uniforms = {\r\n            u_texture: cubeTextures[rand(0, cubeTextures.length) | 0],\r\n            u_viewInverse: camera,\r\n            u_world: m4.identity(),\r\n            u_worldInverseTranspose: m4.identity(),\r\n            u_worldViewProjection: m4.identity(),\r\n          };\r\n          break;\r\n        default:\r\n          throw \"wAT!\";\r\n      }\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shape,\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.BLEND);\r\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var radius = 20;\r\n      var orbitSpeed = time * 0.1;\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [Math.cos(orbitSpeed) * radius, 4, Math.sin(orbitSpeed) * radius];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      updateCanvas(time);\r\n      twgl.setTextureFromElement(gl, textures.fromCanvas, ctx.canvas);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      requestAnimationFrame(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"usesShader": {"one-point": {"@rid":"41:9", "@class":"shader"
, "name":"one-point"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\n\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  gl_Position = u_worldViewProjection * a_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:17:57 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\n\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  if (diffuseColor.a < 0.1) {\r\n    discard;\r\n  }\r\n  gl_FragColor = diffuseColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:17:57 MST 2017 by admin*/"
 ,"description":"used by Textures example\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }
 ,"env-map": {"@rid":"41:10", "@class":"shader"
, "name":"env-map"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_world;\r\nuniform mat4 u_worldViewProjection;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\n\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = u_worldViewProjection * a_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:18:44 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nuniform samplerCube u_texture;\r\n\r\nvarying vec3 v_surfaceToView;\r\nvarying vec3 v_normal;\r\n\r\nvoid main() {\r\n  vec3 normal = normalize(v_normal);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec4 color = textureCube(u_texture, -reflect(surfaceToView, normal));\r\n  gl_FragColor = color;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:18:44 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var onePointProgramInfo = twgl.createProgramInfo(gl, [\"one-point-vs\", \"one-point-fs\"]);\r\n    var envMapProgramInfo = twgl.createProgramInfo(gl, [\"env-map-vs\", \"env-map-fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createPlaneBufferInfo(gl, 2, 2),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      if (max === undefined) {\r\n        max = min;\r\n        min = 0;\r\n      }\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var baseHue = rand(360);\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    // A circle on a canvas\r\n    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\r\n    ctx.canvas.width  = 64;\r\n    ctx.canvas.height = 64;\r\n\r\n    function updateCanvas(time) {\r\n      ctx.fillStyle = \"#00f\";\r\n      ctx.strokeStyle = \"#ff0\";\r\n      ctx.lineWidth = \"10\";\r\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n      ctx.beginPath();\r\n      ctx.arc(ctx.canvas.width / 2, ctx.canvas.height / 2, ctx.canvas.width / 2.2 * Math.abs(Math.cos(time)), 0, Math.PI * 2);\r\n      ctx.stroke();\r\n    }\r\n    updateCanvas(0);\r\n\r\n    // A cubemap drawn to a canvas with a circle on each face.\r\n    var cubemapCtx = document.createElement(\"canvas\").getContext(\"2d\");\r\n    var size = 40;\r\n    cubemapCtx.canvas.width  = size * 6;\r\n    cubemapCtx.canvas.height = size;\r\n    cubemapCtx.fillStyle = \"#888\";\r\n    for (var ff = 0; ff < 6; ++ff) {\r\n      var color = chroma.hsv((baseHue + ff * 10) % 360, 1 - ff / 6, 1);\r\n      cubemapCtx.fillStyle = color.darken().hex();\r\n      cubemapCtx.fillRect(size * ff, 0, size, size);\r\n      cubemapCtx.save();\r\n      cubemapCtx.translate(size * (ff + 0.5), size * 0.5);\r\n      cubemapCtx.beginPath();\r\n      cubemapCtx.arc(0, 0, size * 0.3, 0, Math.PI * 2);\r\n      cubemapCtx.fillStyle = color.hex();\r\n      cubemapCtx.fill();\r\n      cubemapCtx.restore();\r\n    }\r\n\r\n    var textures = twgl.createTextures(gl, {\r\n      // a power of 2 image\r\n      hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\r\n      // a non-power of 2 image\r\n      clover: { src: \"images/clover.jpg\" },\r\n      // From a canvas\r\n      fromCanvas: { src: ctx.canvas },\r\n      // A cubemap from 6 images\r\n      yokohama: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        src: [\r\n          'images/yokohama/posx.jpg',\r\n          'images/yokohama/negx.jpg',\r\n          'images/yokohama/posy.jpg',\r\n          'images/yokohama/negy.jpg',\r\n          'images/yokohama/posz.jpg',\r\n          'images/yokohama/negz.jpg',\r\n        ],\r\n      },\r\n      // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\r\n      goldengate: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        src: 'images/goldengate.jpg',\r\n      },\r\n      // A 2x2 pixel texture from a JavaScript array\r\n      checker: {\r\n        mag: gl.NEAREST,\r\n        min: gl.LINEAR,\r\n        src: [\r\n          255, 255, 255, 255,\r\n          192, 192, 192, 255,\r\n          192, 192, 192, 255,\r\n          255, 255, 255, 255,\r\n        ],\r\n      },\r\n      // a 1x8 pixel texture from a typed array.\r\n      stripe: {\r\n        mag: gl.NEAREST,\r\n        min: gl.LINEAR,\r\n        format: gl.LUMINANCE,\r\n        src: new Uint8Array([\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n        ]),\r\n        width: 1,\r\n      },\r\n      // a cubemap from array\r\n      cubemapFromArray: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        format: gl.RGBA,\r\n        src: [\r\n          0xF0, 0x80, 0x80, 0xFF,\r\n          0x80, 0xE0, 0x80, 0xFF,\r\n          0x80, 0x80, 0xD0, 0xFF,\r\n          0xC0, 0x80, 0x80, 0xFF,\r\n          0x80, 0xB0, 0x80, 0xFF,\r\n          0x80, 0x80, 0x00, 0xFF,\r\n        ],\r\n      },\r\n      cubemapFromCanvas: { target: gl.TEXTURE_CUBE_MAP, src: cubemapCtx.canvas },\r\n    });\r\n\r\n    // This is soley to make it easy to pick textures at random\r\n    var twoDTextures = [\r\n      textures.checker,\r\n      textures.stripe,\r\n      textures.hftIcon,\r\n      textures.clover,\r\n      textures.fromCanvas,\r\n    ];\r\n\r\n    var cubeTextures = [\r\n      textures.yokohama,\r\n      textures.goldengate,\r\n      textures.cubemapFromCanvas,\r\n      textures.cubemapFromArray,\r\n    ];\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms;\r\n      var programInfo;\r\n      var shape;\r\n      var renderType = rand(0, 2) | 0;\r\n      switch (renderType) {\r\n        case 0:  // checker\r\n          shape = shapes[ii % shapes.length];\r\n          programInfo = onePointProgramInfo;\r\n          uniforms = {\r\n            u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n            u_diffuse: twoDTextures[rand(0, twoDTextures.length) | 0],\r\n            u_viewInverse: camera,\r\n            u_world: m4.identity(),\r\n            u_worldInverseTranspose: m4.identity(),\r\n            u_worldViewProjection: m4.identity(),\r\n          };\r\n          break;\r\n        case 1:  // yokohama\r\n          shape = rand(0, 2) < 1 ? shapes[1] : shapes[3];\r\n          programInfo = envMapProgramInfo;\r\n          uniforms = {\r\n            u_texture: cubeTextures[rand(0, cubeTextures.length) | 0],\r\n            u_viewInverse: camera,\r\n            u_world: m4.identity(),\r\n            u_worldInverseTranspose: m4.identity(),\r\n            u_worldViewProjection: m4.identity(),\r\n          };\r\n          break;\r\n        default:\r\n          throw \"wAT!\";\r\n      }\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shape,\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.BLEND);\r\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var radius = 20;\r\n      var orbitSpeed = time * 0.1;\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [Math.cos(orbitSpeed) * radius, 4, Math.sin(orbitSpeed) * radius];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      updateCanvas(time);\r\n      twgl.setTextureFromElement(gl, textures.fromCanvas, ctx.canvas);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      requestAnimationFrame(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"used by Textures example\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }} 
 ,"description":"Uses one-point and env-map shaders"}, 
{"@rid":"41:12", "@class":"shader"
, "name":"2D Lines"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_matrix;\r\nuniform vec4 u_offsets;\r\nuniform vec4 u_centers;\r\nuniform vec4 u_mult;\r\n\r\nattribute vec2 a_position;\r\nattribute vec4 a_color;\r\n\r\nvarying vec4 v_color;\r\n\r\n#define PI 3.14159\r\n\r\nvoid main() {\r\n  vec2 offset = mix(u_offsets.xz, u_offsets.yw, a_position.y);\r\n  float a = u_mult.x * a_position.x * PI * 2.0 + offset.x;//mix(u_offsets.x, u_offsets.y, a_position.y);\r\n  float c = cos(a * u_mult.y);\r\n  vec2 xy = vec2(\r\n    cos(a),\r\n    sin(a)) * c * offset.y +\r\n    mix(u_centers.xy, u_centers.zw, a_position.y);\r\n  gl_Position = u_matrix * vec4(xy, 0, 1);\r\n  v_color = a_color;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:50:25 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_color;\r\n\r\nvoid main() {\r\n  gl_FragColor = v_color;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:50:25 MST 2017 by admin*/\r\n    \"use strict\";\r\n    var m4 = twgl.m4;\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var numLines = 100;\r\n    var arrays = {\r\n      position: twgl.primitives.createAugmentedTypedArray(2, numLines * 2),\r\n      color: twgl.primitives.createAugmentedTypedArray(3, numLines * 2, Uint8Array),\r\n    };\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    var hue = rand(0, 360);\r\n    for (var ii = 0; ii < numLines; ++ii) {\r\n      var u = ii / numLines;\r\n      var h = (360 + hue + (Math.abs(u - 0.5) * 100)) % 360;\r\n      var s = Math.sin(u * Math.PI * 2) * 0.25 + 0.75;\r\n      var v = 1;\r\n      var color = chroma.hsv(h, s, v);\r\n      arrays.position.push(u, 1);\r\n      arrays.color.push(color.rgb());\r\n      arrays.position.push(u, 0);\r\n      arrays.color.push(color.brighten().desaturate().rgb());\r\n    }\r\n\r\n    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\r\n    var offsets = [0, 0, 0, 1];\r\n    var centers = [0, 0, 0, 0];\r\n    var mult =    [1, 2, 0, 0];\r\n    var uniforms = {\r\n      u_matrix: m4.identity(),\r\n      u_offsets: offsets,\r\n      u_centers: centers,\r\n      u_mult: mult,\r\n    };\r\n\r\n    function render() {\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.clearColor(0, 0, 0, 1);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var time = Date.now() * 0.001;\r\n\r\n      offsets[0] = Math.sin(time);\r\n      offsets[1] = Math.sin(time * 0.13) * Math.PI * 2;\r\n      offsets[2] = Math.sin(time * 0.43) * 0.5 + 1.0;\r\n      offsets[3] = Math.cos(time * 0.17) * 0.5 + 0.5;\r\n\r\n      centers[0] = Math.sin(time * 0.163) * 0.5;\r\n      centers[1] = Math.cos(time * 0.267) * 0.5;\r\n      centers[2] = Math.sin(time * 0.367) * 0.5;\r\n      centers[3] = Math.cos(time * 0.497) * 0.5;\r\n\r\n      mult[1] = (Math.sin(time * 0.1) * 0.5 + 0.5) * 3;\r\n\r\n      gl.lineWidth(2);\r\n\r\n      var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      m4.ortho(-aspect, aspect, 1, -1, -1, 1, uniforms.u_matrix);\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      twgl.setUniforms(programInfo, uniforms);\r\n\r\n      twgl.drawBufferInfo(gl, bufferInfo, gl.LINES);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    render();"
 ,"description":"Draw lines\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:13", "@class":"shader"
, "name":"clamped array"
 ,"vertexScript":"/* Vertex Shader */"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:59:06 MST 2017 by admin*/"
 ,"testScript":"/* Shader Test Sat Jan 14 14:59:06 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var onePointProgramInfo = twgl.createProgramInfo(gl, [\"one-point-vs\", \"one-point-fs\"]);\r\n\r\n    // The point of this example is to test using Uint8ClampedArray\r\n    // everywhere possible. So, it's used in both buffer and texture creation\r\n    var arrays = {\r\n      // set normalize false because for int types true is the default (ie, for byte colors and byte normals)\r\n      position: { normalize: false, data: new Int8Array([1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1]) },\r\n      normal:   { normalize: false, data: new Int8Array([1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1]) },\r\n      texcoord: { normalize: false, data: new Uint8ClampedArray([1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1]) },\r\n      indices:  new Uint8ClampedArray([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]),\r\n    };\r\n    var shape = twgl.createBufferInfoFromArrays(gl, arrays);\r\n\r\n    function rand(min, max) {\r\n      if (max === undefined) {\r\n        max = min;\r\n        min = 0;\r\n      }\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var baseHue = rand(360);\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var texture = twgl.createTexture(gl, {\r\n      mag: gl.NEAREST,\r\n      min: gl.LINEAR,\r\n      format: gl.LUMINANCE,\r\n      src: new Uint8ClampedArray([\r\n        255,\r\n        128,\r\n        255,\r\n        128,\r\n        255,\r\n        128,\r\n        255,\r\n        128,\r\n      ]),\r\n      width: 1,\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var programInfo = onePointProgramInfo;\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: texture,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shape,\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.BLEND);\r\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var radius = 20;\r\n      var orbitSpeed = time * 0.1;\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [Math.cos(orbitSpeed) * radius, 4, Math.sin(orbitSpeed) * radius];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Example that uses one-point and env-map\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {"one-point": {"@rid":"41:9", "@class":"shader"
, "name":"one-point"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\n\r\nattribute vec4 a_position;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  gl_Position = u_worldViewProjection * a_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:17:57 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\n\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  if (diffuseColor.a < 0.1) {\r\n    discard;\r\n  }\r\n  gl_FragColor = diffuseColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:17:57 MST 2017 by admin*/"
 ,"description":"used by Textures example\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }
 ,"env-map": {"@rid":"41:10", "@class":"shader"
, "name":"env-map"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_world;\r\nuniform mat4 u_worldViewProjection;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\n\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = u_worldViewProjection * a_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:18:44 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nuniform samplerCube u_texture;\r\n\r\nvarying vec3 v_surfaceToView;\r\nvarying vec3 v_normal;\r\n\r\nvoid main() {\r\n  vec3 normal = normalize(v_normal);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec4 color = textureCube(u_texture, -reflect(surfaceToView, normal));\r\n  gl_FragColor = color;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:18:44 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var onePointProgramInfo = twgl.createProgramInfo(gl, [\"one-point-vs\", \"one-point-fs\"]);\r\n    var envMapProgramInfo = twgl.createProgramInfo(gl, [\"env-map-vs\", \"env-map-fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createPlaneBufferInfo(gl, 2, 2),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      if (max === undefined) {\r\n        max = min;\r\n        min = 0;\r\n      }\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var baseHue = rand(360);\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    // A circle on a canvas\r\n    var ctx = document.createElement(\"canvas\").getContext(\"2d\");\r\n    ctx.canvas.width  = 64;\r\n    ctx.canvas.height = 64;\r\n\r\n    function updateCanvas(time) {\r\n      ctx.fillStyle = \"#00f\";\r\n      ctx.strokeStyle = \"#ff0\";\r\n      ctx.lineWidth = \"10\";\r\n      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);\r\n      ctx.beginPath();\r\n      ctx.arc(ctx.canvas.width / 2, ctx.canvas.height / 2, ctx.canvas.width / 2.2 * Math.abs(Math.cos(time)), 0, Math.PI * 2);\r\n      ctx.stroke();\r\n    }\r\n    updateCanvas(0);\r\n\r\n    // A cubemap drawn to a canvas with a circle on each face.\r\n    var cubemapCtx = document.createElement(\"canvas\").getContext(\"2d\");\r\n    var size = 40;\r\n    cubemapCtx.canvas.width  = size * 6;\r\n    cubemapCtx.canvas.height = size;\r\n    cubemapCtx.fillStyle = \"#888\";\r\n    for (var ff = 0; ff < 6; ++ff) {\r\n      var color = chroma.hsv((baseHue + ff * 10) % 360, 1 - ff / 6, 1);\r\n      cubemapCtx.fillStyle = color.darken().hex();\r\n      cubemapCtx.fillRect(size * ff, 0, size, size);\r\n      cubemapCtx.save();\r\n      cubemapCtx.translate(size * (ff + 0.5), size * 0.5);\r\n      cubemapCtx.beginPath();\r\n      cubemapCtx.arc(0, 0, size * 0.3, 0, Math.PI * 2);\r\n      cubemapCtx.fillStyle = color.hex();\r\n      cubemapCtx.fill();\r\n      cubemapCtx.restore();\r\n    }\r\n\r\n    var textures = twgl.createTextures(gl, {\r\n      // a power of 2 image\r\n      hftIcon: { src: \"images/hft-icon-16.png\", mag: gl.NEAREST },\r\n      // a non-power of 2 image\r\n      clover: { src: \"images/clover.jpg\" },\r\n      // From a canvas\r\n      fromCanvas: { src: ctx.canvas },\r\n      // A cubemap from 6 images\r\n      yokohama: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        src: [\r\n          'images/yokohama/posx.jpg',\r\n          'images/yokohama/negx.jpg',\r\n          'images/yokohama/posy.jpg',\r\n          'images/yokohama/negy.jpg',\r\n          'images/yokohama/posz.jpg',\r\n          'images/yokohama/negz.jpg',\r\n        ],\r\n      },\r\n      // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)\r\n      goldengate: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        src: 'images/goldengate.jpg',\r\n      },\r\n      // A 2x2 pixel texture from a JavaScript array\r\n      checker: {\r\n        mag: gl.NEAREST,\r\n        min: gl.LINEAR,\r\n        src: [\r\n          255, 255, 255, 255,\r\n          192, 192, 192, 255,\r\n          192, 192, 192, 255,\r\n          255, 255, 255, 255,\r\n        ],\r\n      },\r\n      // a 1x8 pixel texture from a typed array.\r\n      stripe: {\r\n        mag: gl.NEAREST,\r\n        min: gl.LINEAR,\r\n        format: gl.LUMINANCE,\r\n        src: new Uint8Array([\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n          255,\r\n          128,\r\n        ]),\r\n        width: 1,\r\n      },\r\n      // a cubemap from array\r\n      cubemapFromArray: {\r\n        target: gl.TEXTURE_CUBE_MAP,\r\n        format: gl.RGBA,\r\n        src: [\r\n          0xF0, 0x80, 0x80, 0xFF,\r\n          0x80, 0xE0, 0x80, 0xFF,\r\n          0x80, 0x80, 0xD0, 0xFF,\r\n          0xC0, 0x80, 0x80, 0xFF,\r\n          0x80, 0xB0, 0x80, 0xFF,\r\n          0x80, 0x80, 0x00, 0xFF,\r\n        ],\r\n      },\r\n      cubemapFromCanvas: { target: gl.TEXTURE_CUBE_MAP, src: cubemapCtx.canvas },\r\n    });\r\n\r\n    // This is soley to make it easy to pick textures at random\r\n    var twoDTextures = [\r\n      textures.checker,\r\n      textures.stripe,\r\n      textures.hftIcon,\r\n      textures.clover,\r\n      textures.fromCanvas,\r\n    ];\r\n\r\n    var cubeTextures = [\r\n      textures.yokohama,\r\n      textures.goldengate,\r\n      textures.cubemapFromCanvas,\r\n      textures.cubemapFromArray,\r\n    ];\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms;\r\n      var programInfo;\r\n      var shape;\r\n      var renderType = rand(0, 2) | 0;\r\n      switch (renderType) {\r\n        case 0:  // checker\r\n          shape = shapes[ii % shapes.length];\r\n          programInfo = onePointProgramInfo;\r\n          uniforms = {\r\n            u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n            u_diffuse: twoDTextures[rand(0, twoDTextures.length) | 0],\r\n            u_viewInverse: camera,\r\n            u_world: m4.identity(),\r\n            u_worldInverseTranspose: m4.identity(),\r\n            u_worldViewProjection: m4.identity(),\r\n          };\r\n          break;\r\n        case 1:  // yokohama\r\n          shape = rand(0, 2) < 1 ? shapes[1] : shapes[3];\r\n          programInfo = envMapProgramInfo;\r\n          uniforms = {\r\n            u_texture: cubeTextures[rand(0, cubeTextures.length) | 0],\r\n            u_viewInverse: camera,\r\n            u_world: m4.identity(),\r\n            u_worldInverseTranspose: m4.identity(),\r\n            u_worldViewProjection: m4.identity(),\r\n          };\r\n          break;\r\n        default:\r\n          throw \"wAT!\";\r\n      }\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shape,\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.BLEND);\r\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var radius = 20;\r\n      var orbitSpeed = time * 0.1;\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [Math.cos(orbitSpeed) * radius, 4, Math.sin(orbitSpeed) * radius];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      updateCanvas(time);\r\n      twgl.setTextureFromElement(gl, textures.fromCanvas, ctx.canvas);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      requestAnimationFrame(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"used by Textures example\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }} }, 
{"@rid":"41:14", "@class":"shader"
, "name":"Concat"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 15:01:41 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              abs(l),//max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 15:01:41 MST 2017 by admin*/\r\n    \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var cubeVertices = twgl.primitives.createCubeVertices(2);\r\n    var sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);\r\n    // move the sphere 2 units up\r\n    twgl.primitives.reorientVertices(\r\n        sphereVertices, twgl.m4.translation([0, 2, 0]));\r\n    // merge the sphere with the cube\r\n    var cubeSphereVertices = twgl.primitives.concatVertices(\r\n        [cubeVertices, sphereVertices]);\r\n    // turn them into WebGL buffers and attrib data\r\n    var cubeSphereBufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);\r\n\r\n    var cubeArrays = {\r\n      position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],\r\n      normal:   [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],\r\n      texcoord: {\r\n        type: Uint8Array,\r\n        normalize: false,\r\n        data: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],\r\n      },\r\n      indices:  [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],\r\n    };\r\n\r\n    var cubes = [];\r\n    for (var zz = 0; zz < 2; ++zz) {\r\n      for (var yy = 0; yy < 2; ++yy) {\r\n        for (var xx = 0; xx < 2; ++xx) {\r\n          cubes.push(twgl.primitives.reorientVertices(\r\n              twgl.primitives.duplicateVertices(cubeArrays), twgl.m4.translation([xx * 2.5, yy * 2.5, zz * 2.5])));\r\n        }\r\n      }\r\n    }\r\n    var cubeCubeVertices = twgl.primitives.concatVertices(cubes);\r\n    var cubeCubeBufferInfo = twgl.createBufferInfoFromArrays(gl, cubeCubeVertices);\r\n\r\n    var shapes = [\r\n      cubeSphereBufferInfo,\r\n      cubeCubeBufferInfo,\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [1, 4, -60];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Object concatenation\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:15", "@class":"shader"
, "name":"Cross origin example"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 15:24:06 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_ambient;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 15:24:06 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var arrays = {\r\n      position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],\r\n      normal:   [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],\r\n      texcoord: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],\r\n      indices:  [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],\r\n    };\r\n    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\r\n\r\n    twgl.setDefaults({crossOrigin: \"\"});\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: \"https://farm6.staticflickr.com/5795/21506301808_efb27ed699_q_d.jpg\",\r\n      crossOrigin: \"\", // either this or use twgl.setDefaults\r\n    });\r\n\r\n    var uniforms = {\r\n      u_lightWorldPos: [1, 5, -10],\r\n      u_lightColor: [1, 1, 1, 1],\r\n      u_ambient: [0, 0, 0, 1],\r\n      u_specular: [1, 1, 1, 1],\r\n      u_shininess: 1,\r\n      u_specularFactor: 0,\r\n      u_diffuse: tex,\r\n    };\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 10);\r\n      var eye = [1, 4, -6];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      var camera = m4.lookAt(eye, target, up);\r\n      var view = m4.inverse(camera);\r\n      var viewProjection = m4.multiply(projection, view);\r\n      var world = m4.rotationY(time);\r\n\r\n      uniforms.u_viewInverse = camera;\r\n      uniforms.u_world = world;\r\n      uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(world));\r\n      uniforms.u_worldViewProjection = m4.multiply(viewProjection, world);\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      twgl.setUniforms(programInfo, uniforms);\r\n      gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Example using a external resource\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:17", "@class":"shader"
, "name":"FOV checker"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_viewProjection;\r\nuniform mat4 u_world;\r\n\r\nattribute vec4 a_position;\r\n\r\nvoid main() {\r\n  gl_Position = u_viewProjection * u_world * a_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 16:21:22 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nuniform vec4 u_color;\r\n\r\nvoid main() {\r\n    gl_FragColor = u_color;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 16:21:22 MST 2017 by admin*/\r\n    \"use strict\";\r\n\r\n// GJI Added this to dynamically create the needed HTML elements\r\n\tvar udiv = document.createElement(\"div\");\r\n\tudiv.setAttribute(\"id\",\"u\");\r\n\r\n\tvar inpu = document.createElement(\"input\");\r\n\tinpu.setAttribute(\"id\",\"fov\");\r\n\tinpu.setAttribute(\"type\",\"range\");\r\n\tinpu.setAttribute(\"min\",1);\r\n\tinpu.setAttribute(\"max\",179);\r\n\tudiv.appendChild(inpu);\r\n\r\n\tvar utab = document.createElement(\"table\");\r\n\tfor (let nn of [\"fovy\",\"fovx\",\"badfovx\",\"width\",\"height\",\"aspect\"]) {\r\n     console.log(\"nn=\"+nn); \r\n      var row = document.createElement(\"tr\");\r\n      var label = document.createElement(\"td\");\r\n      label.appendChild(document.createTextNode(nn));\r\n      \r\n      var val = document.createElement(\"td\");\r\n      val.setAttribute(\"id\",nn);\r\n      \r\n      row.appendChild(label);\r\n      row.appendChild(val);\r\n      utab.appendChild(row);\r\n    }\r\n\tudiv.appendChild(utab);\r\n\tdocument.body.appendChild(udiv);\r\n// GJI end of added code\r\n\r\n\r\n\tvar m4 = twgl.m4;\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    function createSphere(\r\n        gl,\r\n        radius,\r\n        subdivisionsAxis,\r\n        subdivisionsHeight,\r\n        hConnect,\r\n        vConnect,\r\n        startLatitudeInRadians,\r\n        endLatitudeInRadians,\r\n        startLongitudeInRadians,\r\n        endLongitudeInRadians) {\r\n\r\n      hConnect = hConnect === false ? false : true;\r\n      vConnect = vConnect === false ? false : true;\r\n\r\n      startLatitudeInRadians  = startLatitudeInRadians  || 0;\r\n      endLatitudeInRadians    = endLatitudeInRadians    || Math.PI;\r\n      startLongitudeInRadians = startLongitudeInRadians || 0;\r\n      endLongitudeInRadians   = endLongitudeInRadians   || Math.PI * 2;\r\n\r\n      var latRange = endLatitudeInRadians - startLatitudeInRadians;\r\n      var longRange = endLongitudeInRadians - startLongitudeInRadians;\r\n\r\n      // We are going to generate our sphere by iterating through its\r\n      // spherical coordinates and generating 2 lines for each quad on a\r\n      // ring of the sphere.\r\n      var numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);\r\n      var positions = twgl.primitives.createAugmentedTypedArray(3, numVertices);\r\n      var normals   = twgl.primitives.createAugmentedTypedArray(3, numVertices);\r\n      var texCoords = twgl.primitives.createAugmentedTypedArray(2 , numVertices);\r\n\r\n      // Generate the individual vertices in our vertex buffer.\r\n      for (var y = 0; y <= subdivisionsHeight; y++) {\r\n        for (var x = 0; x <= subdivisionsAxis; x++) {\r\n          // Generate a vertex based on its spherical coordinates\r\n          var u = x / subdivisionsAxis;\r\n          var v = y / subdivisionsHeight;\r\n          var theta = startLongitudeInRadians + longRange * u;\r\n          var phi =   startLatitudeInRadians + latRange * v;\r\n          var sinTheta = Math.sin(theta);\r\n          var cosTheta = Math.cos(theta);\r\n          var sinPhi = Math.sin(phi);\r\n          var cosPhi = Math.cos(phi);\r\n          var ux = cosTheta * sinPhi;\r\n          var uy = cosPhi;\r\n          var uz = sinTheta * sinPhi;\r\n          positions.push(radius * ux, radius * uy, radius * uz);\r\n          normals.push(ux, uy, uz);\r\n          texCoords.push(1 - u, v);\r\n        }\r\n      }\r\n\r\n      var numVertsAround = subdivisionsAxis + 1;\r\n      var linesPerQuad = (hConnect ? 1 : 0) + (vConnect ? 1 : 0);\r\n      var indices = twgl.primitives.createAugmentedTypedArray(2, subdivisionsAxis * subdivisionsHeight * linesPerQuad, Uint16Array);\r\n      for (var x = 0; x < subdivisionsAxis; x++) {  // eslint-disable-line\r\n        for (var y = 0; y < subdivisionsHeight; y++) {  // eslint-disable-line\r\n          // Make hline of quad.\r\n          if (hConnect) {\r\n            indices.push(\r\n                (y + 0) * numVertsAround + x,\r\n                (y + 0) * numVertsAround + x + 1);\r\n          }\r\n\r\n          // Make vline of quad.\r\n          if (vConnect) {\r\n            indices.push(\r\n                (y + 1) * numVertsAround + x,\r\n                (y + 0) * numVertsAround + x);\r\n          }\r\n        }\r\n      }\r\n\r\n      return twgl.createBufferInfoFromArrays(gl, {\r\n        position: positions,\r\n        normal: normals,\r\n        texcoord: texCoords,\r\n        indices: indices,\r\n      });\r\n    }\r\n\r\n    function deg2Rad(d) {\r\n      return d * Math.PI / 180;\r\n    }\r\n\r\n    function rad2Deg(r) {\r\n      return r * 180 / Math.PI;\r\n    }\r\n\r\n    var radius = 10;\r\n    var a = Math.PI * 1.5;\r\n    var b = Math.PI * 0.5;\r\n    var c = 0.01;\r\n    var vMarksSphere = createSphere(gl, radius, 2, 180, true, false, 0, Math.PI, a - c, a + c);\r\n    var hMarksSphere = createSphere(gl, radius, 360, 2, false, true, b - c, b + c, 0, Math.PI * 2);\r\n    var highDetailSphere = createSphere(gl, radius, 36 * 2, 18 * 2);\r\n    var detailSphere = createSphere(gl, radius, 36, 18);\r\n    var v3rdsSphere = createSphere(gl, radius, 12, 36, false, true);\r\n    var h3rdsSphere = createSphere(gl, radius, 36, 6, true, false);\r\n    var vQuadSphere = createSphere(gl, radius, 4, 36, false, true);\r\n    var hQuadSphere = createSphere(gl, radius, 36, 2, true, false);\r\n\r\n    /**\r\n     *   0---1\r\n     *   |   |\r\n     *   2---3\r\n     *   |   |\r\n     *   4---5\r\n     */\r\n    var numberPositions = [\r\n      -1,  1,  1,  1,\r\n      -1,  0,  1,  0,\r\n      -1, -1,  1, -1,\r\n    ];\r\n\r\n    var numberIndices = [\r\n      [ 0, 1, 1, 5, 5, 4, 4, 0 ], // 0\r\n      [ 1, 5 ],  // 1\r\n      [ 0, 1, 1, 3, 3, 2, 2, 4, 4, 5 ], // 2\r\n      [ 0, 1, 1, 5, 5, 4, 2, 3 ],       // 3\r\n      [ 0, 2, 2, 3, 1, 5 ],             // 4\r\n      [ 1, 0, 0, 2, 2, 3, 3, 5, 5, 4 ], // 5\r\n      [ 1, 0, 0, 4, 4, 5, 5, 3, 3, 2 ], // 6\r\n      [ 0, 1, 1, 5 ],                   // 7\r\n      [ 0, 1, 1, 5, 5, 4, 4, 0, 2, 3 ], // 8\r\n      [ 3, 2, 2, 0, 0, 1, 1, 5 ],       // 9\r\n    ];\r\n\r\n    var total = 0;\r\n    var numberInfos = numberIndices.map(function(indices) {\r\n      var offset = total;\r\n      var count  = indices.length;\r\n      total += count;\r\n      return {\r\n        offset: offset * 2,\r\n        count: count,\r\n      };\r\n    });\r\n\r\n    var numberBufferInfo = twgl.createBufferInfoFromArrays(gl, {\r\n      position: { numComponents: 2, data: numberPositions },\r\n      indices:  { numComponents: 2, data: Array.prototype.concat.apply([], numberIndices) },\r\n    });\r\n\r\n    var fieldOfViewY = deg2Rad(30);\r\n    var viewProjection = m4.identity();\r\n\r\n    var drawObjects = [\r\n      { programInfo: programInfo,\r\n        bufferInfo: vMarksSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0.3, 0.3, 0.3, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: hMarksSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0.3, 0.3, 0.3, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: highDetailSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0.3, 0.3, 0.3, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: detailSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0, 0, 1, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: h3rdsSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0, 1, 0, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: v3rdsSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0, 1, 0, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: hQuadSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [1, 0, 0, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: vQuadSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [1, 0, 0, 1],\r\n        },\r\n      },\r\n    ];\r\n\r\n    function addNumber(value, world) {\r\n      var str = value.toString();\r\n      var length = str.length;\r\n      var letterSize = 2.0;\r\n      var padding = 0.6;\r\n      var scale = [0.2, 0.2, 1];\r\n      var spacing = letterSize + padding;\r\n      var xOffset = (length - 1) * (spacing) * -0.5;\r\n      Array.prototype.forEach.call(str, function(digit, ndx) {\r\n        var mat = m4.copy(world);\r\n        m4.scale(mat, scale, mat);\r\n        m4.translate(mat, [xOffset + ndx * spacing, 0, 0], mat);\r\n        var digitNdx = parseInt(digit);\r\n        var numberInfo = numberInfos[digitNdx];\r\n        drawObjects.push({\r\n          programInfo: programInfo,\r\n          bufferInfo: numberBufferInfo,\r\n          type: gl.LINES,\r\n          offset: numberInfo.offset,\r\n          count: numberInfo.count,\r\n          uniforms: {\r\n            u_world: mat,\r\n            u_viewProjection: viewProjection,\r\n            u_color: [1, 1, 1, 1],\r\n          },\r\n        });\r\n      });\r\n    }\r\n\r\n    // Add numbers around sphere\r\n    for (var ii = -180; ii < 180; ii += 10) {\r\n      var world = m4.identity();\r\n      m4.rotateY(world, deg2Rad(ii), world);\r\n      m4.translate(world, [0, 0, -radius], world);\r\n      addNumber(Math.abs(ii), world);\r\n\r\n      world = m4.identity();\r\n      m4.rotateX(world, deg2Rad(ii), world);\r\n      m4.translate(world, [0, 0, -radius], world);\r\n      addNumber(Math.abs(ii), world);\r\n    }\r\n\r\n    function render() {\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.clearColor(0, 0, 0, 1);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      gl.lineWidth(2);\r\n\r\n      var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      var zNear  = 0.1;\r\n      var zFar   = 50;\r\n      m4.perspective(fieldOfViewY, aspect, zNear, zFar, viewProjection);\r\n      //m4.translate(matrix, [0, 0, -40], matrix);\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n    }\r\n\r\n    function createTextNodeInElement(id) {\r\n      console.log(\"create text node in \"+id);\r\n      var elem = document.getElementById(id);\r\n      var node = document.createTextNode(\"\");\r\n      elem.appendChild(node);\r\n      return node;\r\n    }\r\n\r\n    function makeNodes(ids) {\r\n      var nodes = {};\r\n      ids.forEach(function(id) {\r\n        nodes[id] = createTextNodeInElement(id);\r\n      });\r\n      return nodes;\r\n    }\r\n\r\n    var rangeElem = document.getElementById(\"fov\");\r\n    var nodes = makeNodes([\"fovy\", \"fovx\", \"width\", \"height\", \"aspect\", \"badfovx\"]);\r\n    rangeElem.value = 30;\r\n\r\n    function updateNodes() {\r\n      var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      var fieldOfViewX = 2 * Math.atan(Math.tan(fieldOfViewY * 0.5) * aspect);\r\n      var badFieldOfViewX = fieldOfViewY * aspect;\r\n\r\n      nodes.fovy.nodeValue    = rad2Deg(fieldOfViewY).toFixed(2);\r\n      nodes.fovx.nodeValue    = rad2Deg(fieldOfViewX).toFixed(2);\r\n      nodes.badfovx.nodeValue = rad2Deg(badFieldOfViewX).toFixed(2);\r\n      nodes.width.nodeValue   = gl.canvas.clientWidth;\r\n      nodes.height.nodeValue  = gl.canvas.clientHeight;\r\n      nodes.aspect.nodeValue  = aspect.toFixed(3);\r\n    }\r\n    updateNodes();\r\n\r\n    function updateFOV() {\r\n      fieldOfViewY = deg2Rad(rangeElem.value);\r\n      updateNodes();\r\n      render();\r\n    }\r\n\r\n    rangeElem.addEventListener('input', updateFOV, false);\r\n    window.addEventListener('resize', updateFOV, false);\r\n\r\n    render();"
 ,"description":"Field of view display\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:21", "@class":"shader"
, "name":"Compute shader example"
 ,"vertexScript":"/* Vertex Shader */"
 ,"fragmentScript":"/* Fragment Shader Sun Jan 15 15:45:18 MST 2017 by admin*/"
 ,"testScript":"/* Shader Test Sun Jan 15 15:45:18 MST 2017 by admin*/\r\n\t\r\n// Utils\r\nwindow.onerror = function (msg, url, lineno) {\r\n\talert(url + '(' + lineno + '): ' + msg);\r\n}\r\n\r\nfunction createShader (str, type) {\r\n\tvar shader = gl.createShader(type);\r\n\tgl.shaderSource(shader, str);\r\n\tgl.compileShader(shader);\r\n\tif (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\r\n\t\tthrow gl.getShaderInfoLog(shader);\r\n\treturn shader;\r\n}\r\n\r\nfunction createProgram (vstr, fstr) {\r\n\tvar program = gl.createProgram();\r\n\tvar vshader = createShader(vstr, gl.VERTEX_SHADER);\r\n\tvar fshader = createShader(fstr, gl.FRAGMENT_SHADER);\r\n\tgl.attachShader(program, vshader);\r\n\tgl.attachShader(program, fshader);\r\n\tgl.linkProgram(program);\r\n\tif (!gl.getProgramParameter(program, gl.LINK_STATUS))\r\n\t\tthrow gl.getProgramInfoLog(program);\r\n\treturn program;\r\n}\r\n\r\nfunction screenQuad () {\r\n\tvar vertexPosBuffer = gl.createBuffer();\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);\r\n\tvar vertices = [-1, -1, 1, -1, -1, 1, 1, 1];\r\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n\tvertexPosBuffer.itemSize = 2;\r\n\tvertexPosBuffer.numItems = 4;\r\n\treturn vertexPosBuffer;\r\n}\r\n\r\nfunction linkProgram (program) {\r\n\tvar vshader = createShader(program.vshaderSource, gl.VERTEX_SHADER);\r\n\tvar fshader = createShader(program.fshaderSource, gl.FRAGMENT_SHADER);\r\n\tgl.attachShader(program, vshader);\r\n\tgl.attachShader(program, fshader);\r\n\tgl.linkProgram(program);\r\n\tif (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n\t\tthrow gl.getProgramInfoLog(program);\r\n\t}\r\n}\r\n\r\nfunction loadFile (file, callback, noCache, isJson) {\r\n\tvar request = new XMLHttpRequest();\r\n\trequest.onreadystatechange = function() {\r\n\t\tif (request.readyState == 1) {\r\n\t\t\tif (isJson) \r\n\t\t\t\trequest.overrideMimeType('application/json');\r\n\t\t\trequest.send();\r\n\t\t} else if (request.readyState == 4) {\r\n\t\t\tif (request.status == 200) \r\n\t\t\t\tcallback(request.responseText);\r\n\t\t\telse if (request.status == 404) \r\n\t\t\t\tthrow 'File \"' + file + '\" does not exist.';\r\n\t\t\telse \r\n\t\t\t\tthrow 'XHR error ' + request.status + '.';\r\n\t\t}\r\n\t};\r\n\tvar url = file;\r\n\tif (noCache) \r\n\t\turl += '?' + (new Date()).getTime();\r\n\trequest.open('GET', url, true);\r\n}\r\n\r\nfunction loadProgram (vs, fs, callback) {\r\n\tvar program = gl.createProgram();\r\n\tfunction vshaderLoaded(str) {\r\n\t\tprogram.vshaderSource = str;\r\n\t\tif (program.fshaderSource) {\r\n\t\t\tlinkProgram(program);\r\n\t\t\tcallback(program);\r\n\t\t}\r\n\t}\r\n\tfunction fshaderLoaded (str) {\r\n\t\tprogram.fshaderSource = str;\r\n\t\tif (program.vshaderSource) {\r\n\t\t\tlinkProgram(program);\r\n\t\t\tcallback(program);\r\n\t\t}\r\n\t}\r\n\tloadFile(vs, vshaderLoaded, true);\r\n\tloadFile(fs, fshaderLoaded, true);\r\n\treturn program;\r\n}\r\n\r\n(function() {\r\n    var lastTime = 0;\r\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\r\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\r\n        window.cancelRequestAnimationFrame = window[vendors[x] + 'CancelRequestAnimationFrame'];\r\n    }\r\n\r\n    if (!window.requestAnimationFrame)\r\n        window.requestAnimationFrame = function (callback, element) {\r\n            var currTime = new Date().getTime();\r\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);\r\n            lastTime = currTime + timeToCall;\r\n            return id;\r\n        };\r\n\r\n    if (!window.cancelAnimationFrame)\r\n        window.cancelAnimationFrame = function (id) {\r\n            clearTimeout(id);\r\n        };\r\n}())\r\n\r\nfunction prepScreenQuad () {\r\n\tvar vertexPosBuffer = gl.createBuffer();\r\n\tgl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);\r\n\tvar vertices = [-1, -1, 1, -1, -1, 1, 1, 1];\r\n\tgl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);\r\n\tvertexPosBuffer.itemSize = 2;\r\n    vertexPosBuffer.numItems = 4;\r\n\treturn vertexPosBuffer;\r\n}\r\n\r\n// Code\r\nvar vertex_shader_source                = 'attribute vec2 aVertexPosition; varying vec2 vTexCoord; void main() { vTexCoord = aVertexPosition; gl_Position = vec4(aVertexPosition, 0, 1); }'; \r\n\t\tvar fragment_shader_source_header       = 'precision mediump float; varying vec2 vTexCoord;';\r\n\t\tvar fragment_shader_source_random       = 'uniform float uTime; float random (vec2 seed) { return fract(cos(mod(123456780., 1024. * dot(seed / uTime, vec2(23.1406926327792690, 2.6651441426902251))))); }';\r\n\t\tvar fragment_shader_source_encode_float = 'float shift_right (float v, float amt) { v = floor(v) + 0.5; return floor(v / exp2(amt)); } float shift_left (float v, float amt) { return floor(v * exp2(amt) + 0.5); } float mask_last (float v, float bits) { return mod(v, shift_left(1.0, bits)); } float extract_bits (float num, float from, float to) { from = floor(from + 0.5); to = floor(to + 0.5); return mask_last(shift_right(num, from), to - from); } vec4 encode_float (float val) { if (val == 0.0) return vec4(0, 0, 0, 0); float sign = val > 0.0 ? 0.0 : 1.0; val = abs(val); float exponent = floor(log2(val)); float biased_exponent = exponent + 127.0; float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; float t = biased_exponent / 2.0; float last_bit_of_biased_exponent = fract(t) * 2.0; float remaining_bits_of_biased_exponent = floor(t); float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; return vec4(byte4, byte3, byte2, byte1); }';\r\n\t\tvar fragment_shader_source_uniform_wrap = 'uniform float {{name}};';\r\n\t\tvar fragment_shader_source_body         = 'void main() { gl_FragColor = encode_float(i); }';\r\n\t\t\r\n\t\tfunction GenerateGPUFunction (Uniforms, CellCount, FloatsOut) {\r\n\t\t\t// create a canvas\r\n\t\t\tvar canvas = document.getElementById('c');\r\n\t\t\t\r\n\t\t\t// determine canvas size by number of cells needed\r\n\t\t\tCellCount = Math.ceil(Math.sqrt(CellCount));\r\n\t\t\tcanvas.width  = CellCount;\r\n\t\t\tcanvas.height = CellCount;\r\n\t\t\t// get gl context from canvas (note that we preserve the drawing buffer to maintain pixel readability, might work without)\r\n\t\t\tgl = canvas.getContext('experimental-webgl', {preserveDrawingBuffer: true});\r\n\t\t\t\r\n\t\t\t// create full quad to cover canvas\r\n\t\t\tvar quad = screenQuad();\r\n\t\t\t// create the vertex shader source\r\n\t\t\tvar vs = vertex_shader_source;\r\n\t\t\t\r\n\t\t\t// create the fragment shader source\r\n\t\t\t// fragment shader header\r\n        \tvar fs = fragment_shader_source_header;\r\n        \t// add uniforms\r\n        \tfor (var u = 0; u < Uniforms.length; u++)\r\n        \t\tfs += fragment_shader_source_uniform_wrap.split('{{name}}').join(Uniforms[u]);\r\n        \t\r\n        \t// add random function\r\n        \tfs += fragment_shader_source_random;\r\n        \t// add encode float function\r\n        \tfs += fragment_shader_source_encode_float; \r\n        \t\r\n        \t// add the main function\r\n        \tfs += fragment_shader_source_body;\r\n        \t// create the program\r\n        \tvar program = createProgram(vs, fs);\r\n        \t// shake and bake\r\n        \treturn function GeneratedGPUFunction (UniformValues, Cells) {\r\n\t\t\t\t// load program\r\n\t\t\t\tgl.useProgram(program);\r\n\t\t\t\t\r\n\t\t\t\t// get gpu vertex position location\r\n\t\t\t\tprogram.aVertexPosition = gl.getAttribLocation (program, 'aVertexPosition');\r\n\t\t\t\t\r\n\t\t\t\t// get time uniform location\r\n\t\t\t\tprogram.uTime = gl.getUniformLocation(program, 'uTime');\r\n\t\t\t\t\r\n\t\t\t\t// create object to hold user uniforms\r\n\t\t\t\tprogram.UserUniforms = {};\r\n\t\t\t\t\r\n\t\t\t\t// get locations for all user uniforms\r\n\t\t\t\tfor (var u = 0; u < Uniforms.length; u++) \r\n\t\t\t\t\tprogram.UserUniforms[Uniforms[u]] = gl.getUniformLocation(program, Uniforms[u]);\r\n\t\t\t\t// enable vertex attributes\r\n\t\t\t\tgl.enableVertexAttribArray(program.vertexPosArray);\r\n\t\t\t\t\r\n\t\t\t\t// load verticies\r\n\t\t\t\tgl.vertexAttribPointer(program.aVertexPosition, quad.itemSize, gl.FLOAT, false, 0, 0);\r\n\t\t\t\t\r\n\t\t\t\t// load time uniform\r\n\t\t\t\tgl.uniform1f(program.uTime, new Date().getTime());\r\n\t\t\t\r\n\t\t\t\t// load all user uniform values\r\n\t\t\t\tfor (var u = 0; u < Uniforms.length; u++) \r\n\t\t\t\t\tgl.uniform1f(program.UserUniforms[Uniforms[u]], UniformValues[u]);\r\n\t\t\t\t// draw\r\n\t\t\t\tgl.drawArrays(gl.TRIANGLE_STRIP, 0, quad.numItems);\r\n\t\t\t\r\n\t\t\t\t// create buffer to hold pixels\r\n\t\t\t\tPixelsOutBuffer = new Uint8Array(canvas.width * canvas.height * 4);\r\n\t\t\t\t\r\n\t\t\t\t// read pixels into buffer\r\n\t\t\t\tgl.readPixels(0, 0, canvas.width, canvas.height, gl.RGBA, gl.UNSIGNED_BYTE, PixelsOutBuffer);\r\n\t\t\t\t// if the output is floats\r\n        \t\tif (FloatsOut)\r\n        \t\t\t// convert output to floats\r\n        \t\t\treturn new Float32Array(PixelsOutBuffer.buffer)\r\n        \t\telse\r\n        \t\t\t// return outputs as bytes\r\n        \t\t\treturn PixelsOutBuffer;\r\n        \t};\r\n\t\t};\r\n\t\tvar gpufn = GenerateGPUFunction(['i'], 16, true);\r\n\t\tfor (var i = 0; i < 100; i++)\r\n\t\t\tconsole.log(gpufn([i], null));"
 ,"description":"Straight JavaScript no twgl - output to console"
 ,"usesShader": {} }, 
{"@rid":"41:22", "@class":"shader"
, "name":"Packed arrays"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Mon Jan 16 23:58:13 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              abs(l),//max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Mon Jan 16 23:58:13 MST 2017 by admin*/\r\n    \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n// ------------------------------------------------------------------\r\n// This is all the code needed to automatically pack unpacked arrays\r\n// It's not included in TWGL because packing unpacked arrays seems\r\n// like overkill. Do you really gain much? If you're really going\r\n// for perf it seems like you'd pack offline\r\n\r\n    function isArrayBuffer(a) {\r\n      return a && a.buffer && a.buffer instanceof ArrayBuffer;\r\n    }\r\n\r\n    function getGLTypeForArray(array, arrayName) {\r\n      if (isArrayBuffer(array)) {\r\n        return twgl.getGLTypeForTypedArray(array);\r\n      }\r\n\r\n      if (isArrayBuffer(array.data)) {\r\n        return twgl.getGLTypeForTypedArray(array.data);\r\n      }\r\n\r\n      var Type = array.type;\r\n      if (!Type) {\r\n        if (arrayName === \"indices\") {\r\n          Type = Uint16Array;\r\n        } else {\r\n          Type = Float32Array;\r\n        }\r\n      }\r\n      return twgl.getGLTypeForTypedArray(new Type(0));\r\n    }\r\n\r\n    function getNormalizationForGLType(gl, type) {\r\n      switch (type) {\r\n        case gl.BYTE:\r\n        case gl.UNSIGNED_BYTE:\r\n          return true;\r\n        default:\r\n          return false;\r\n      }\r\n    }\r\n\r\n    function getNumBytesForGLType(type) {\r\n      switch (type) {\r\n        case gl.BYTE:           return 1;  // eslint-disable-line\r\n        case gl.UNSIGNED_BYTE:  return 1;  // eslint-disable-line\r\n        case gl.SHORT:          return 2;  // eslint-disable-line\r\n        case gl.UNSIGNED_SHORT: return 2;  // eslint-disable-line\r\n        case gl.INT:            return 4;  // eslint-disable-line\r\n        case gl.UNSIGNED_INT:   return 4;  // eslint-disable-line\r\n        case gl.FLOAT:          return 4;  // eslint-disable-line\r\n        default:\r\n          throw \"unknown gl type\";\r\n      }\r\n    }\r\n\r\n    var defaultAttribPrefix = \"a_\";\r\n    function createPackedBufferInfoFromArrays(gl, arrays) {\r\n      // compute size of array needed and offsets\r\n      var offset      = 0;\r\n      var maxElements = 0;\r\n\r\n      var attribs = {};\r\n\r\n      Object.keys(arrays).forEach(function(arrayName) {\r\n        if (arrayName === \"indices\") {\r\n          return;\r\n        }\r\n        var array = arrays[arrayName];\r\n        var attribName = array.attrib || array.name || array.attribName || (defaultAttribPrefix + arrayName);\r\n        var glType = getGLTypeForArray(array, arrayName);\r\n        var attrib = {\r\n          numComponents: array.numComponents || array.size || guessNumComponentsFromName(arrayName),\r\n          type:          glType,\r\n          normalize:     array.normalize !== undefined ? array.normalize : getNormalizationForGLType(gl, glType),\r\n          offset:        offset,\r\n        };\r\n        attribs[attribName] = attrib;\r\n        var sizeInBytes = attrib.numComponents * getNumBytesForGLType(glType);\r\n        // should we handle padding? For example RGB8 is 3 bytes and will need padding\r\n        offset += sizeInBytes;\r\n        // should we check that all lengths are the same?\r\n        var length = array.length || array.data.length;\r\n        var numElements = length / attrib.numComponents;\r\n        maxElements = Math.max(maxElements, numElements);\r\n      });\r\n\r\n      var stride = offset;\r\n      var arrayBuffer = new ArrayBuffer(stride * maxElements);\r\n      var buffer = gl.createBuffer();\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n      Object.keys(arrays).forEach(function(arrayName) {\r\n        if (arrayName === \"indices\") {\r\n          return;\r\n        }\r\n        var array = arrays[arrayName];\r\n        var attribName = array.attrib || array.name || array.attribName || (defaultAttribPrefix + arrayName);\r\n        var attrib = attribs[attribName];\r\n        attrib.buffer = buffer;\r\n        attrib.stride = stride;\r\n        var data = array.length ? array : array.data;\r\n        var length = data.length;\r\n        var numComponents = attrib.numComponents;\r\n        var numElements = length / numComponents;\r\n        var Type = twgl.getTypedArrayTypeForGLType(attrib.type);\r\n        var view = new Type(arrayBuffer, attrib.offset);\r\n        var localStride = stride / getNumBytesForGLType(attrib.type);\r\n        var offset = 0;\r\n        var index = 0;\r\n        for (var elem = 0; elem < numElements; ++elem) {\r\n          for (var component = 0; component < numComponents; ++component) {\r\n            view[offset + component] = data[index++];\r\n          }\r\n          offset += localStride;\r\n        }\r\n      });\r\n\r\n      gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);\r\n\r\n      var bufferInfo = {\r\n        attribs: attribs,\r\n      };\r\n      var indices = arrays.indices;\r\n      if (indices) {\r\n        bufferInfo.indices = twgl.createBufferFromArray(gl, indices, \"indices\");\r\n        bufferInfo.numElements = indices.length || indices.data.length;\r\n        bufferInfo.elementType = (indices instanceof Uint32Array) ?  gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\r\n      } else {\r\n        bufferInfo.numElements = numElements;\r\n      }\r\n\r\n      return bufferInfo;\r\n    }\r\n\r\n// end of packing code\r\n// -------------------------------------------------------\r\n\r\n    var shapes = [\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createCubeVertices(2)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createSphereVertices(1, 24, 12)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createPlaneVertices(2, 2)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createTruncatedConeVertices(1, 0, 2, 24, 1)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createCresentVertices(1, 1, 0.5, 0.1, 24)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createCylinderVertices(1, 2, 24, 2)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createDiscVertices(1, 24)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createTorusVertices(1, 0.4, 24, 12)),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [1, 4, -40];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"adapted from https://twgljs.org/ example"
 ,"usesShader": {} }, 
{"@rid":"41:23", "@class":"shader"
, "name":"WebGL2 VaryingsFeedback"
 ,"vertexScript":"#version 300 es\r\n/* Vertex Shader */\r\n  in vec4 aPos;\r\nvoid main(void) {\r\n   gl_PointSize = 20.;\r\n   gl_Position = vec4(aPos.x - 0.01, aPos.yzw);\r\n}"
 ,"fragmentScript":"#version 300 es\r\n/* Fragment Shader Tue Jan 17 11:02:46 MST 2017 by admin*/\r\nprecision highp float;\r\n  out vec4 fragColor;\r\nvoid main(void) {\r\n   fragColor = vec4( 1.,0.,0., 1. );\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 11:02:46 MST 2017 by admin*/\r\nvar but = document.createElement(\"button\");\r\nbut.setAttribute(\"onClick\",\"draw()\");\r\nbut.appendChild(document.createTextNode(\"Next\"));\r\ndocument.body.appendChild(but);\r\n\r\nfunction getShader ( gl, id ){\r\n   var shaderScript = document.getElementById ( id );\r\n   var str = \"\";\r\n   var k = shaderScript.firstChild;\r\n   while ( k ){\r\n     if ( k.nodeType == 3 ) str += k.textContent;\r\n     k = k.nextSibling;\r\n   }\r\n   var shader;\r\n   if ( shaderScript.type == \"x-shader/x-fragment\" )\r\n           shader = gl.createShader ( gl.FRAGMENT_SHADER );\r\n   else if ( shaderScript.type == \"x-shader/x-vertex\" )\r\n           shader = gl.createShader(gl.VERTEX_SHADER);\r\n   else return null;\r\n   gl.shaderSource(shader, str);\r\n   gl.compileShader(shader);\r\n   if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)\r\n      alert(id + \"\n\" + gl.getShaderInfoLog(shader));\r\n   return shader;\r\n}\r\n\r\nvar gl, bufA, bufB, aPosLoc\r\nfunction webGLStart() {\r\n   var canvas = document.getElementById(\"c\")\r\n   var err = \"Your browser does not support \"\r\n   if (!window.WebGLRenderingContext){\r\n    alert(err + \"WebGL. See http://get.webgl.org\"); return}\r\n   try { gl = canvas.getContext(\"webgl2\")\r\n   } catch(e) {}\r\n   if ( !gl ) {alert(\"Can't get WebGL2\"); return}\r\n     \r\n   var prog  = gl.createProgram()\r\n   gl.attachShader(prog, getShader( gl, \"vs\" ))\r\n   gl.attachShader(prog, getShader( gl, \"fs\" ))\r\n   gl.transformFeedbackVaryings( prog, [\"gl_Position\"], gl.SEPARATE_ATTRIBS )\r\n   gl.linkProgram(prog)\r\n   gl.useProgram(prog)\r\n\r\n   aPosLoc = gl.getAttribLocation(prog, \"aPos\")\r\n   gl.enableVertexAttribArray( aPosLoc )\r\n\r\n   bufA = gl.createBuffer()\r\n   gl.bindBuffer(gl.ARRAY_BUFFER, bufA)\r\n   gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([.8,0,0,1]), gl.DYNAMIC_COPY)\r\n\r\n   bufB = gl.createBuffer()\r\n   gl.bindBuffer(gl.ARRAY_BUFFER, bufB)\r\n   gl.bufferData(gl.ARRAY_BUFFER, 4*4, gl.DYNAMIC_COPY)\r\n\r\n   var transformFeedback = gl.createTransformFeedback()\r\n   gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback)\r\n\r\n   draw();\r\n}\r\n\r\nfunction draw(){\r\n   gl.clear(gl.COLOR_BUFFER_BIT)\r\n\r\n   gl.bindBuffer(gl.ARRAY_BUFFER, bufA)\r\n   gl.vertexAttribPointer(aPosLoc, 4, gl.FLOAT, gl.FALSE, 0, 0)\r\n   gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, bufB)\r\n\r\n   gl.beginTransformFeedback(gl.POINTS)\r\n   gl.drawArrays(gl.POINTS, 0, 1)\r\n   gl.endTransformFeedback()\r\n\r\n   gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null)\r\n\r\n   var t = bufA;  bufA = bufB;  bufB = t\r\n}\r\n\r\nwebGLStart();"
 ,"description":"requires webgl2 move a square when button pressed - calced in gpu"}, 
{"@rid":"41:24", "@class":"shader"
, "name":"Particles (non-twgl)"
 ,"vertexScript":"/* Vertex Shader */\r\nprecision mediump float;\r\n  attribute vec2 Vertex; varying vec2 V; uniform float T;\r\n  void main(void) {\r\n  gl_PointSize = 2.; V = Vertex;\r\n  vec2 v = Vertex*(mod(T+length(Vertex),1.));\r\n  float ct = (cos(v.x*30.+T*20.)+cos(v.y*30.+T*20.));\r\n  v = mat2(sin(v.x*(10.+ct)),cos(v.x*(10.+ct)),cos(v.y*(10.+ct)),sin(v.y*(10.+ct)))*v;\r\n  gl_Position=vec4(v,0.,1.);\r\n  }"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 12:49:03 MST 2017 by admin*/\r\nprecision mediump float; \r\nvarying vec2 V; \r\nuniform float T;\r\n\r\n  void main(void) {\r\n  gl_FragColor = vec4(.4,.9,.8,.1);\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 12:49:03 MST 2017 by admin*/\r\n//This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\r\n//by Ethan Shulman\r\n\r\nvar width = 640;\r\nvar height = 480;\r\n\r\nvar vbuf;\r\nvar pstart;\r\nvar nump;\r\n\r\nvar canvasElement;\r\nvar gl;\r\nwindow.onload = function() {\r\n  canvasElement = document.getElementById(\"c\");\r\n  canvasElement.width = width;\r\n  canvasElement.height = height;\r\n  \r\n  gl = canvasElement.getContext(\"webgl\");\r\n  if (!gl) {\r\n    gl = canvasElement.getContext(\"experimental-webgl\");\r\n    if (!gl) alert(\"WebGL not supported!\");\r\n  }\r\n  \r\n  nump = 5000;\r\n  pstart = new Float32Array(nump*2);\r\n  var i = pstart.length;\r\n  while (i--) {\r\n    pstart[i] = 0;\r\n    while (pstart[i]*pstart[i] < .3) {\r\n      pstart[i] = Math.random()*2-1;\r\n    }\r\n  }\r\n  \r\n  vbuf = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER,vbuf);\r\n  gl.bufferData(gl.ARRAY_BUFFER,pstart,gl.STATIC_DRAW);\r\n  \r\n  var vsh = gl.createShader(gl.VERTEX_SHADER);\r\n  gl.shaderSource(vsh,\r\n  \"\nprecision mediump float;\"+\r\n  \"attribute vec2 Vertex; varying vec2 V; uniform float T;\"+\r\n  \"void main(void) {\"+\r\n  \"gl_PointSize = 2.; V = Vertex;\"+\r\n  \"vec2 v = Vertex*(mod(T+length(Vertex),1.));\"+\r\n  \"float ct = (cos(v.x*30.+T*20.)+cos(v.y*30.+T*20.));\"+\r\n  \"v = mat2(sin(v.x*(10.+ct)),cos(v.x*(10.+ct)),cos(v.y*(10.+ct)),sin(v.y*(10.+ct)))*v;\"+\r\n  \"gl_Position=vec4(v,0.,1.);\"+\r\n  \"}\"               \r\n                 );\r\n  gl.compileShader(vsh);\r\n  \r\n  var fsh = gl.createShader(gl.FRAGMENT_SHADER);\r\n  gl.shaderSource(fsh,\r\n  \"\nprecision mediump float; varying vec2 V; uniform float T;\"+\r\n  \"void main(void) {\"+\r\n  \"gl_FragColor = vec4(.4,.9,.8,.1);}\");\r\n  \r\n  gl.compileShader(fsh);\r\n  \r\n  var program = gl.createProgram();\r\n  gl.attachShader(program,vsh);\r\n  gl.attachShader(program,fsh);\r\n  gl.linkProgram(program);\r\n  gl.useProgram(program);\r\n  \r\n  var vattr = gl.getAttribLocation(program,\"Vertex\");\r\n  gl.enableVertexAttribArray(vattr);\r\n  gl.vertexAttribPointer(vbuf,2,gl.FLOAT,false,4,0);\r\n  \r\n  tuni = gl.getUniformLocation(program,\"T\");\r\n  \r\n  gl.enable(gl.BLEND);\r\n  gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA);\r\n  \r\n  gl.disable(gl.DEPTH_TEST);\r\n  \r\n  gl.clearColor(0,0,0,1);\r\n  \r\n  if (!window.requestAnimationFrame) window.requestAnimationFrame = setTimeout;\r\n    \r\n  startTime = Date.now();\r\n  render();\r\n}\r\n                \r\n var tuni,startTime;      \r\nfunction render() {\r\n  //gl.clear(gl.COLOR_BUFFER_BIT);\r\n  gl.uniform1f(tuni,(Date.now()-startTime)/30000.);\r\n  gl.drawArrays(gl.POINTS,0,nump);\r\n  \r\n  SHADER_CONTROLS(render);\r\n}"
 ,"description":"Example using straight WebGL calls"
 ,"usesShader": {} }, 
{"@rid":"41:25", "@class":"shader"
, "name":"WebGL particles"
 ,"vertexScript":"/* Vertex Shader */"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 13:02:26 MST 2017 by admin*/"
 ,"testScript":"/* Shader Test Tue Jan 17 13:02:26 MST 2017 by admin*/\r\n\r\n// \r\n// Constants\r\n// \r\n\r\nconst PARTICLE_COUNT = Math.pow(1024, 2);\r\nconst PARTICLE_COUNT_SQRT = Math.sqrt(PARTICLE_COUNT);\r\nconst PARTICLE_DATA_SLOTS = 2;\r\nconst PARTICLE_DATA_WIDTH = PARTICLE_COUNT_SQRT * PARTICLE_DATA_SLOTS;\r\nconst PARTICLE_DATA_HEIGHT = PARTICLE_COUNT_SQRT;\r\nconst PARTICLE_EMIT_RATE = 1000;\r\n\r\n// \r\n// Globals\r\n// \r\n\r\nlet physicsInputTexture;\r\nlet physicsOutputTexture;\r\nlet dataLocationBuffer;\r\nlet viewportQuadBuffer;\r\nlet particleTexture;\r\nlet physicsProgram;\r\nlet renderProgram;\r\nlet debugProgram;\r\nlet copyProgram;\r\nlet frameBuffer;\r\nlet container;\r\nlet emitIndex;\r\nlet lastEmit;\r\nlet millis;\r\nlet height;\r\nlet width;\r\nlet scale;\r\nlet clock;\r\nlet gl;\r\n\r\n// \r\n// GL Utils\r\n// \r\n\r\nconst createContext = () => {\r\n  const el = document.getElementById('c');\r\n  const gl = el.getContext('webgl') || el.getContext('experimental-webgl');\r\n  if (!gl) {\r\n    throw 'WebGL not supported';\r\n  }\r\n  if (!gl.getExtension('OES_texture_float')) {\r\n    throw 'Float textures not supported';\r\n  }\r\n  return gl;\r\n};\r\n\r\nfunction getShader ( gl, id ){\r\n   var shaderScript = document.getElementById ( id );\r\n  if (!shaderScript) alert(\"error getting shader: \"+id);\r\n   var str = \"\";\r\n   var k = shaderScript.firstChild;\r\n   while ( k ){\r\n     if ( k.nodeType == 3 ) str += k.textContent;\r\n     k = k.nextSibling;\r\n   }\r\n   var shader;\r\n   if ( shaderScript.type == \"x-shader/x-fragment\" )\r\n           shader = gl.createShader ( gl.FRAGMENT_SHADER );\r\n   else if ( shaderScript.type == \"x-shader/x-vertex\" )\r\n           shader = gl.createShader(gl.VERTEX_SHADER);\r\n   else return null;\r\n   gl.shaderSource(shader, str);\r\n   gl.compileShader(shader);\r\n   if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)\r\n      alert(id + \"\n\" + gl.getShaderInfoLog(shader));\r\n   return shader;\r\n}\r\n\r\nconst createShader = (source, type) => {\r\n  const shader = gl.createShader(type);\r\n  gl.shaderSource(shader, source);\r\n  gl.compileShader(shader);\r\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n    throw gl.getShaderInfoLog(shader);\r\n  }\r\n  return shader;\r\n};\r\n\r\nconst createProgram = (vSource, fSource) => {\r\n  console.log(\"get shader \"+vSource+\", \"+fSource);\r\n  const vs = getShader(gl, vSource);\r\n  const fs = getShader(gl, fSource);\r\n  const program = gl.createProgram();\r\n  gl.attachShader(program, vs);\r\n  gl.attachShader(program, fs);\r\n  gl.linkProgram(program);\r\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n    throw gl.getProgramInfoLog(program);\r\n  }\r\n  return program;\r\n};\r\n\r\nconst createDataTexture = (width, height, data) => {\r\n  const texture = gl.createTexture();\r\n  gl.bindTexture(gl.TEXTURE_2D, texture);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, data);\r\n  return texture;\r\n};\r\n\r\nconst createFramebuffer = () => {\r\n  const buffer = gl.createFramebuffer();\r\n  return buffer;\r\n};\r\n\r\n// \r\n// Helpers\r\n// \r\n\r\nconst random = (min, max) => {\r\n  if (typeof min !== 'number') min = 1;\r\n  if (typeof max !== 'number') max = min, min = 0;\r\n  return min + Math.random() * (max - min);\r\n};\r\n\r\nconst createPhysicsProgram = () => {\r\n  const program = createProgram(\"physics-vs\", \"physics-fs\");\r\n  program.vertexPosition = gl.getAttribLocation(program, 'vertexPosition');\r\n  program.physicsData = gl.getUniformLocation(program, 'physicsData');\r\n  program.bounds = gl.getUniformLocation(program, 'bounds');\r\n  gl.enableVertexAttribArray(program.vertexPosition);\r\n  return program;\r\n};\r\n\r\nconst createRenderProgram = () => {\r\n  const program = createProgram(\"render-vs\",\"render-fs\");\r\n  program.dataLocation = gl.getAttribLocation(program, 'dataLocation');\r\n  program.particleTexture = gl.getUniformLocation(program, 'particleTexture');\r\n  program.physicsData = gl.getUniformLocation(program, 'physicsData');\r\n  gl.enableVertexAttribArray(program.dataLocation);\r\n  return program;\r\n};\r\n\r\nconst createDebugProgram = () => {\r\n  const program = createProgram(\"debug-vs\", \"debug-fs\");\r\n  program.vertexPosition = gl.getAttribLocation(program, 'vertexPosition');\r\n  program.texture = gl.getUniformLocation(program, 'texture');\r\n  gl.enableVertexAttribArray(program.vertexPosition);\r\n  return program;\r\n};\r\n\r\nconst createCopyProgram = () => {\r\n  const program = createProgram(\"copy-vs\", \"copy-fs\");\r\n  program.vertexPosition = gl.getAttribLocation(program, 'vertexPosition');\r\n  program.texture = gl.getUniformLocation(program, 'texture');\r\n  gl.enableVertexAttribArray(program.vertexPosition);\r\n  return program;\r\n};\r\n\r\nconst createPhysicsDataTexture = () => {\r\n  const size = 4 * PARTICLE_COUNT * PARTICLE_DATA_SLOTS;\r\n  const data = new Float32Array(size);\r\n  return createDataTexture(PARTICLE_DATA_WIDTH, PARTICLE_DATA_HEIGHT, data);\r\n};\r\n\r\nconst createDataLocationBuffer = () => {\r\n  const data = new Float32Array(PARTICLE_COUNT * 2);\r\n  const step = 1 / PARTICLE_COUNT_SQRT;\r\n  for (let u, v, i = 0; i < PARTICLE_COUNT; i++) {\r\n    u = i * 2;\r\n    v = u + 1;\r\n    data[u] = step * Math.floor(i % PARTICLE_COUNT_SQRT);\r\n    data[v] = step * Math.floor(i / PARTICLE_COUNT_SQRT);\r\n  }\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\r\n  return buffer;\r\n};\r\n\r\nconst createViewportQuadBuffer = () => {\r\n  const data = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\r\n  const buffer = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\r\n  return buffer;\r\n};\r\n\r\nconst emitParticles = (count, origin, velocities = [0, 0, 0]) => {\r\n  gl.bindTexture(gl.TEXTURE_2D, physicsInputTexture);\r\n  const x = Math.floor((emitIndex * PARTICLE_DATA_SLOTS) % PARTICLE_DATA_WIDTH);\r\n  const y = Math.floor(emitIndex / PARTICLE_DATA_HEIGHT);\r\n  const chunks = [[x, y, count * PARTICLE_DATA_SLOTS]];\r\n  const split = (chunk) => {\r\n    const boundary = chunk[0] + chunk[2];\r\n    if (boundary > PARTICLE_DATA_WIDTH) {\r\n      const delta = boundary - PARTICLE_DATA_WIDTH;\r\n      chunk[2] -= delta;\r\n      chunk = [0, (chunk[1] + 1) % PARTICLE_DATA_HEIGHT, delta];\r\n      chunks.push(chunk);\r\n      split(chunk);\r\n    }\r\n  };\r\n  split(chunks[0]);\r\n  let i, j, n, m, chunk, data, force = 1.0;\r\n  for (i = 0, n = chunks.length; i < n; i++) {\r\n    chunk = chunks[i];\r\n    data = [];\r\n    for (j = 0, m = chunk[2]; j < m; j++) {\r\n      data.push(\r\n        origin[0] + random(-0.02, 0.02),\r\n        origin[1] + random(-0.02, 0.02),\r\n        origin[2] + random(-0.01, 0.01),\r\n        random(10),\r\n        velocities[0] + force * random(-1, 1),\r\n        velocities[1] + force * random(-1, 1),\r\n        velocities[2] + force * random(-1, 1),\r\n        0\r\n      );\r\n    }\r\n    gl.texSubImage2D(\r\n      gl.TEXTURE_2D, 0, chunk[0], chunk[1], chunk[2], 1,\r\n      gl.RGBA, gl.FLOAT, new Float32Array(data)\r\n    );\r\n  }\r\n  emitIndex += count;\r\n  emitIndex %= PARTICLE_COUNT;\r\n  console.log(\"Emitted \"+count+\" particles\");\r\n};\r\n\r\nconst leap = () => {\r\n  if (typeof Leap !== 'undefined') {\r\n    Leap.loop(frame => {\r\n      const fingers = frame.pointables;\r\n      for (let i = 0, n = fingers.length; i < n; i++) {\r\n        const { tipPosition, tipVelocity } = fingers[i];\r\n        const count = random(110, 200);\r\n        const position = [\r\n          (tipPosition.x / 200),\r\n          (tipPosition.y / 200) - 1\r\n          (tipPosition.z / 400) * -1\r\n        ];\r\n        const velocity = [\r\n          tipVelocity.x / 100,\r\n          tipVelocity.y / 120,\r\n          tipVelocity.z / 180\r\n        ];\r\n        emitParticles(count, position, velocity);\r\n      }\r\n    });\r\n  }\r\n};\r\n\r\n// \r\n// Main\r\n// \r\n\r\nconst init = () => {\r\n  console.log(\"init\");\r\n  gl = createContext();\r\n  container = document.getElementById('c');\r\n  emitIndex = 0;\r\n  millis = 0;\r\n  clock = Date.now();\r\n  document.addEventListener('touchmove', touch);\r\n  document.addEventListener('mousemove', touch);\r\n  window.addEventListener('resize', resize);\r\n  setup();\r\n  resize();\r\n  update();\r\n  //leap();\r\n  console.log(\"init complete\");\r\n};\r\n\r\nconst setup = () => {\r\n  physicsInputTexture = createPhysicsDataTexture();\r\n  physicsOutputTexture = createPhysicsDataTexture();\r\n  dataLocationBuffer = createDataLocationBuffer();\r\n  viewportQuadBuffer = createViewportQuadBuffer();\r\n  particleTexture = twgl.createTexture(gl, { src: \"/images/misc/particle.png\",\r\n         min: gl.LINEAR_MIPMAP_NEAREST,  max: gl.LINEAR,\r\n       wrapS: gl.CLAMP_TO_EDGE, wrapT: gl.CLAMP_TO_EDGE} );\r\n  physicsProgram = createPhysicsProgram();\r\n  renderProgram = createRenderProgram();\r\n  debugProgram = createDebugProgram();\r\n  copyProgram = createCopyProgram();\r\n  frameBuffer = createFramebuffer();\r\n  console.log(\"setup complete\");\r\n};\r\n\r\nconst physics = () => {\r\n  gl.useProgram(physicsProgram);\r\n  gl.viewport(0, 0, PARTICLE_DATA_WIDTH, PARTICLE_DATA_HEIGHT);\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, viewportQuadBuffer);\r\n  gl.vertexAttribPointer(physicsProgram.vertexPosition, 2, gl.FLOAT, gl.FALSE, 0, 0);\r\n  gl.uniform2f(physicsProgram.bounds, PARTICLE_DATA_WIDTH, PARTICLE_DATA_HEIGHT);\r\n  gl.activeTexture(gl.TEXTURE0);\r\n  gl.bindTexture(gl.TEXTURE_2D, physicsInputTexture);\r\n  gl.uniform1i(physicsProgram.physicsData, 0);\r\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\r\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, physicsOutputTexture, 0);\r\n  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n};\r\n\r\nconst copy = () => {\r\n  gl.useProgram(copyProgram);\r\n  gl.viewport(0, 0, PARTICLE_DATA_WIDTH, PARTICLE_DATA_HEIGHT);\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, viewportQuadBuffer);\r\n  gl.vertexAttribPointer(copyProgram.vertexPosition, 2, gl.FLOAT, gl.FALSE, 0, 0);\r\n  gl.activeTexture(gl.TEXTURE0);\r\n  gl.bindTexture(gl.TEXTURE_2D, physicsOutputTexture);\r\n  gl.uniform1i(copyProgram.physicsData, 0);\r\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\r\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, physicsInputTexture, 0);\r\n  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n};\r\n\r\nconst debug = () => {\r\n  const x = 16 * scale;\r\n  const y = 16 * scale;\r\n  const w = 360 * scale;\r\n  const h = 180 * scale;\r\n  gl.useProgram(debugProgram);\r\n  gl.viewport(x, y, w, h);\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, viewportQuadBuffer);\r\n  gl.vertexAttribPointer(physicsProgram.vertexPosition, 2, gl.FLOAT, gl.FALSE, 0, 0);\r\n  gl.activeTexture(gl.TEXTURE0);\r\n  gl.bindTexture(gl.TEXTURE_2D, physicsOutputTexture);\r\n  gl.uniform1i(debugProgram.texture, 0);\r\n  gl.enable(gl.BLEND);\r\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n  gl.disable(gl.BLEND);\r\n};\r\n\r\nconst render = () => {\r\n  gl.useProgram(renderProgram);\r\n  gl.clear(gl.COLOR_BUFFER_BIT);\r\n  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, dataLocationBuffer);\r\n  gl.vertexAttribPointer(renderProgram.dataLocation, 2, gl.FLOAT, gl.FALSE, 0, 0);\r\n  gl.activeTexture(gl.TEXTURE0);\r\n  gl.bindTexture(gl.TEXTURE_2D, physicsOutputTexture);\r\n  gl.uniform1i(renderProgram.physicsData, 0);\r\n  gl.activeTexture(gl.TEXTURE1);\r\n  gl.bindTexture(gl.TEXTURE_2D, particleTexture);\r\n  gl.uniform1i(renderProgram.particleTexture, 1);\r\n  gl.enable(gl.BLEND);\r\n  gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\r\n  gl.drawArrays(gl.POINTS, 0, PARTICLE_COUNT);\r\n  gl.disable(gl.BLEND);\r\n};\r\n\r\nconst tick = () => {\r\n  const now = Date.now();\r\n  millis += now - clock || 0;\r\n  clock = now;\r\n};\r\n\r\nconst spawn = () => {\r\n  if (millis < 3000) {\r\n    emitParticles(800, [\r\n      -1.0 + Math.sin(millis * 0.001) * 2.0,\r\n      -0.2 + Math.cos(millis * 0.004) * 0.5,\r\n      Math.sin(millis * 0.015) * -0.05\r\n    ]);\r\n  }\r\n};\r\n\r\nconst touch = (event) => {\r\n  if (millis - lastEmit < 20) return;\r\n  const touches = event.changedTouches || [event];\r\n  const limit = PARTICLE_EMIT_RATE / touches.length;\r\n  for (let i = 0; i < touches.length; i++) {\r\n    const touch = touches[i];\r\n    const x = (touch.clientX / width) * 2 - 1;\r\n    const y = (touch.clientY / height) * -2 + 1;\r\n    emitParticles(limit, [x, y, 0]);\r\n  }\r\n  lastEmit = millis;\r\n};\r\n\r\nconst resize = () => {\r\n  scale = window.devicePixelRatio || 1;\r\n  twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n  width = gl.canvas.width;\r\n  height = gl.canvas.height;\r\n};\r\n\r\nconst update = () => {\r\n  tick();    // Advance the clock\r\n  spawn();   // Spawn new particles (only at beginning)\r\n  physics(); // Run the physics\r\n  copy();    // Copy the result\r\n  render();  // Render the result\r\n  debug();   // Show the calculation texture\r\n  \r\n  SHADER_CONTROLS(update);\r\n//  requestAnimationFrame(update);\r\n};\r\n\r\n// \r\n// Bootstrap\r\n// \r\n\r\nif (document.readyState === 'complete') init()\r\nelse window.addEventListener('load', init);"
 ,"description":"Compute movements of over a million particles using intermediate textures\r\nadapted from example at https://soulwire.co.uk/webgl-gpu-particles/"
 ,"usesShader": {"render": {"@rid":"41:29", "@class":"shader"
, "name":"particles-render"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec2 dataLocation;\r\nuniform sampler2D physicsData;\r\nvoid main() {\r\n  vec4 particle = texture2D(physicsData, dataLocation);\r\n  float perspective = 1.0 + particle.z * 5.5;\r\n  float phase = cos(particle.w) * max(0.5, tan(particle.z * 8.05));\r\n  gl_Position = vec4(particle.xyz, perspective);\r\n  gl_PointSize = min(64.0, (1.0 / perspective) * (0.75 + phase));\r\n}"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 18:03:31 MST 2017 by admin*/\r\nuniform sampler2D particleTexture;\r\nvoid main() {\r\n  gl_FragColor = texture2D(particleTexture, gl_PointCoord);\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 18:03:31 MST 2017 by admin*/"
 ,"description":"used by WebGL Particles"
 ,"usesShader": {} }
 ,"debug": {"@rid":"41:27", "@class":"shader"
, "name":"particles-debug"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec2 vertexPosition;\r\nvarying vec2 coord;\r\nvoid main() {\r\n  coord = (vertexPosition + 1.0) / 2.0;\r\n  gl_Position = vec4(vertexPosition, 1, 1);\r\n}"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 18:01:51 MST 2017 by admin*/\r\nprecision mediump float;\r\nuniform sampler2D texture;\r\nvarying vec2 coord;\r\nvoid main() {\r\n  vec3 rgb = texture2D(texture, coord).xyz;\r\n  gl_FragColor = vec4(rgb, 0.5);\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 18:01:51 MST 2017 by admin*/"
 ,"description":"used by WebGL Particles"
 ,"usesShader": {} }
 ,"copy": {"@rid":"41:26", "@class":"shader"
, "name":"particles-copy"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec2 vertexPosition;\r\nvarying vec2 coord;\r\nvoid main() {\r\n  coord = (vertexPosition + 1.0) / 2.0;\r\n  gl_Position = vec4(vertexPosition, 1, 1);\r\n}"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 18:00:21 MST 2017 by admin*/\r\nprecision mediump float;\r\nuniform sampler2D texture;\r\nvarying vec2 coord;\r\nvoid main() {\r\n  gl_FragColor = texture2D(texture, coord);\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 18:00:21 MST 2017 by admin*/"
 ,"description":"used by WebGL Particles"
 ,"usesShader": {} }
 ,"physics": {"@rid":"41:28", "@class":"shader"
, "name":"particles-physics"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec2 vertexPosition;\r\nvoid main() {\r\n  gl_Position = vec4(vertexPosition, 1, 1);\r\n}"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 18:02:40 MST 2017 by admin*/\r\nprecision mediump float;\r\nuniform sampler2D physicsData;\r\nuniform vec2 bounds;\r\nconst vec3 TARGET = vec3(0, 0, 0.01);\r\nconst int POSITION_SLOT = 0;\r\nconst int VELOCITY_SLOT = 1;\r\nvec4 texel(vec2 offset) {\r\n  vec2 coord = (gl_FragCoord.xy + offset) / bounds;\r\n  return texture2D(physicsData, coord);\r\n}\r\nvoid main() {\r\n  int slot = int(mod(gl_FragCoord.x, 2.0));\r\n  if (slot == POSITION_SLOT) {\r\n    vec4 dataA = texel(vec2(0, 0));\r\n    vec4 dataB = texel(vec2(1, 0));\r\n    vec3 position = dataA.xyz;\r\n    vec3 velocity = dataB.xyz;\r\n    float phase = dataA.w;\r\n    if (phase > 0.0) {\r\n      position += velocity * 0.005;\r\n      if (length(TARGET - position) < 0.035) phase = 0.0;\r\n      else phase += 0.1;\r\n    } else {\r\n      position = vec3(-1);\r\n    }\r\n    gl_FragColor = vec4(position, phase);\r\n  } else if (slot == VELOCITY_SLOT) {\r\n    vec4 dataA = texel(vec2(-1, 0));\r\n    vec4 dataB = texel(vec2(0, 0));\r\n    vec3 position = dataA.xyz;\r\n    vec3 velocity = dataB.xyz;\r\n    float phase = dataA.w;\r\n    if (phase > 0.0) {\r\n      vec3 delta = normalize(TARGET - position);\r\n      velocity += delta * 0.05;\r\n      velocity *= 0.991;\r\n    } else {\r\n      velocity = vec3(0);\r\n    }\r\n    gl_FragColor = vec4(velocity, 1);\r\n  }\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 18:02:40 MST 2017 by admin*/"
 ,"description":"used by WebGL Particles"
 ,"usesShader": {} }} }, 
{"@rid":"41:26", "@class":"shader"
, "name":"particles-copy"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec2 vertexPosition;\r\nvarying vec2 coord;\r\nvoid main() {\r\n  coord = (vertexPosition + 1.0) / 2.0;\r\n  gl_Position = vec4(vertexPosition, 1, 1);\r\n}"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 18:00:21 MST 2017 by admin*/\r\nprecision mediump float;\r\nuniform sampler2D texture;\r\nvarying vec2 coord;\r\nvoid main() {\r\n  gl_FragColor = texture2D(texture, coord);\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 18:00:21 MST 2017 by admin*/"
 ,"description":"used by WebGL Particles"
 ,"usesShader": {} }, 
{"@rid":"41:27", "@class":"shader"
, "name":"particles-debug"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec2 vertexPosition;\r\nvarying vec2 coord;\r\nvoid main() {\r\n  coord = (vertexPosition + 1.0) / 2.0;\r\n  gl_Position = vec4(vertexPosition, 1, 1);\r\n}"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 18:01:51 MST 2017 by admin*/\r\nprecision mediump float;\r\nuniform sampler2D texture;\r\nvarying vec2 coord;\r\nvoid main() {\r\n  vec3 rgb = texture2D(texture, coord).xyz;\r\n  gl_FragColor = vec4(rgb, 0.5);\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 18:01:51 MST 2017 by admin*/"
 ,"description":"used by WebGL Particles"
 ,"usesShader": {} }, 
{"@rid":"41:28", "@class":"shader"
, "name":"particles-physics"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec2 vertexPosition;\r\nvoid main() {\r\n  gl_Position = vec4(vertexPosition, 1, 1);\r\n}"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 18:02:40 MST 2017 by admin*/\r\nprecision mediump float;\r\nuniform sampler2D physicsData;\r\nuniform vec2 bounds;\r\nconst vec3 TARGET = vec3(0, 0, 0.01);\r\nconst int POSITION_SLOT = 0;\r\nconst int VELOCITY_SLOT = 1;\r\nvec4 texel(vec2 offset) {\r\n  vec2 coord = (gl_FragCoord.xy + offset) / bounds;\r\n  return texture2D(physicsData, coord);\r\n}\r\nvoid main() {\r\n  int slot = int(mod(gl_FragCoord.x, 2.0));\r\n  if (slot == POSITION_SLOT) {\r\n    vec4 dataA = texel(vec2(0, 0));\r\n    vec4 dataB = texel(vec2(1, 0));\r\n    vec3 position = dataA.xyz;\r\n    vec3 velocity = dataB.xyz;\r\n    float phase = dataA.w;\r\n    if (phase > 0.0) {\r\n      position += velocity * 0.005;\r\n      if (length(TARGET - position) < 0.035) phase = 0.0;\r\n      else phase += 0.1;\r\n    } else {\r\n      position = vec3(-1);\r\n    }\r\n    gl_FragColor = vec4(position, phase);\r\n  } else if (slot == VELOCITY_SLOT) {\r\n    vec4 dataA = texel(vec2(-1, 0));\r\n    vec4 dataB = texel(vec2(0, 0));\r\n    vec3 position = dataA.xyz;\r\n    vec3 velocity = dataB.xyz;\r\n    float phase = dataA.w;\r\n    if (phase > 0.0) {\r\n      vec3 delta = normalize(TARGET - position);\r\n      velocity += delta * 0.05;\r\n      velocity *= 0.991;\r\n    } else {\r\n      velocity = vec3(0);\r\n    }\r\n    gl_FragColor = vec4(velocity, 1);\r\n  }\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 18:02:40 MST 2017 by admin*/"
 ,"description":"used by WebGL Particles"
 ,"usesShader": {} }, 
{"@rid":"41:29", "@class":"shader"
, "name":"particles-render"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec2 dataLocation;\r\nuniform sampler2D physicsData;\r\nvoid main() {\r\n  vec4 particle = texture2D(physicsData, dataLocation);\r\n  float perspective = 1.0 + particle.z * 5.5;\r\n  float phase = cos(particle.w) * max(0.5, tan(particle.z * 8.05));\r\n  gl_Position = vec4(particle.xyz, perspective);\r\n  gl_PointSize = min(64.0, (1.0 / perspective) * (0.75 + phase));\r\n}"
 ,"fragmentScript":"/* Fragment Shader Tue Jan 17 18:03:31 MST 2017 by admin*/\r\nuniform sampler2D particleTexture;\r\nvoid main() {\r\n  gl_FragColor = texture2D(particleTexture, gl_PointCoord);\r\n}"
 ,"testScript":"/* Shader Test Tue Jan 17 18:03:31 MST 2017 by admin*/"
 ,"description":"used by WebGL Particles"
 ,"usesShader": {} } ] }
