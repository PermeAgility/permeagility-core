{ "shader":[ {"@rid":"41:0", "@class":"shader"
, "name":"Primitives example"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Thu Jan 12 00:57:48 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0, abs(l), (l > 0.0) ? pow(max(0.0, h), m) : 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight), dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((u_lightColor * (diffuseColor * litR.y + u_specular * litR.z * u_specularFactor)).rgb, diffuseColor.a);\r\n  \r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Thu Jan 12 00:58:14 MST 2017 by glenn */\r\n  \"use strict\";\r\n\r\n\r\n\ttwgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createPlaneBufferInfo(gl, 2, 2),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n      twgl.primitives.createCresentBufferInfo(gl, 1, 1, 0.5, 0.1, 24),\r\n      twgl.primitives.createCylinderBufferInfo(gl, 1, 2, 24, 2),\r\n      twgl.primitives.createDiscBufferInfo(gl, 1, 24),\r\n      twgl.primitives.createTorusBufferInfo(gl, 1, 0.4, 24, 12),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [1, 4, -30];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Checker textured primitives floating around\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} },
{"@rid":"41:2", "@class":"shader"
, "name":"ncolor shader"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"precision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,  abs(l),  (l > 0.0) ? pow(max(0.0, h), m) : 0.0, 1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec3 normal = normalize(v_normal);\r\n  vec4 diffuseColor = vec4(normal * 0.5 + 0.5, 1);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(normal, surfaceToLight),\r\n                    dot(normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Thu Jan 12 00:58:14 MST 2017 by glenn */\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createPlaneBufferInfo(gl, 2, 2),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n      twgl.primitives.createCresentBufferInfo(gl, 1, 1, 0.5, 0.1, 24),\r\n      twgl.primitives.createCylinderBufferInfo(gl, 1, 2, 24, 2),\r\n      twgl.primitives.createDiscBufferInfo(gl, 1, 24),\r\n      twgl.primitives.createTorusBufferInfo(gl, 1, 0.4, 24, 12),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [1, 4, -30];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Dynamic colored primitives\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} },
{"@rid":"41:4", "@class":"shader"
, "name":"kaleid shader"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec4 a_position;\r\n    attribute vec2 a_id;\r\n    varying vec2 v_texcoord;\r\n    uniform mat4 u_matrix;\r\n    uniform mat4 u_projection;\r\n    uniform float u_angleTime;\r\n    uniform float u_angleScale;\r\n    void main() {\r\n      vec4 localPosition = u_matrix * a_position;\r\n      float angle = a_id.x * u_angleScale + u_angleTime;\r\n      float radius = localPosition.y;\r\n      float c = cos(angle);\r\n      float s = sin(angle);\r\n      mat4 m = mat4(\r\n          vec4(c, s, 0, 0),\r\n          vec4(-s, c, 0, 0),\r\n          vec4(0, 0, 1, 0),\r\n          vec4(0, 0, 0, 1));\r\n      gl_Position = u_projection * m * localPosition;\r\n      v_texcoord = a_position.xy * 0.5 + 0.5;\r\n    }"
 ,"fragmentScript":"/* Fragment Shader Fri Jan 13 21:25:42 MST 2017 by admin*/\r\n  precision mediump float;\r\n\r\n    varying vec2 v_texcoord;\r\n    uniform sampler2D u_texture;\r\n\r\n    void main() {\r\n      gl_FragColor = texture2D(u_texture, v_texcoord);\r\n    }"
 ,"testScript":"/* Shader Test Fri Jan 13 21:25:42 MST 2017 by admin*/"
 ,"description":"used by Kaleidoscope"
 ,"usesShader": {} },
{"@rid":"41:5", "@class":"shader"
, "name":"Kaleidoscope"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Fri Jan 13 21:26:44 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_ambient;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\nuniform float u_fogNear;\r\nuniform float u_fogFar;\r\nuniform vec4 u_fogColor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              abs(l),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  float depth = gl_FragCoord.z / gl_FragCoord.w;\r\n  float fogFactor = smoothstep(u_fogNear, u_fogFar, depth);\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = mix(outColor, u_fogColor, fogFactor);\r\n}"
 ,"testScript":"/* Shader Test Fri Jan 13 21:26:44 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n    var kaleidProgramInfo = twgl.createProgramInfo(gl, [\"kaleid-vs\", \"kaleid-fs\"]);\r\n\r\n    function createUnitQuadsBufferInfo(gl, across, down) {\r\n      var numQuads    = across * down;\r\n      var numVertices = 4 * numQuads;\r\n      var numIndices  = 6 * numQuads;\r\n\r\n      var positions = twgl.primitives.createAugmentedTypedArray(3, numVertices);\r\n      var ids       = twgl.primitives.createAugmentedTypedArray(2, numVertices, Uint16Array);\r\n      var indices   = twgl.primitives.createAugmentedTypedArray(3, numIndices, Uint16Array);\r\n\r\n      var verts = [\r\n        -1, -1, -1,\r\n         1, -1,  0,\r\n        -1,  1,  0,\r\n         1,  1,  1,\r\n      ];\r\n\r\n      var ndx = 0;\r\n      for (var yy = 0; yy < down; ++yy) {\r\n        for (var xx = 0; xx < across; ++xx) {\r\n          positions.push(verts);\r\n          ids.push(xx, yy, xx, yy, xx, yy, xx, yy);\r\n          indices.push(ndx + 0, ndx + 1, ndx + 2, ndx + 2, ndx + 1, ndx + 3);\r\n          ndx += 4;\r\n        }\r\n      }\r\n\r\n      return twgl.createBufferInfoFromArrays(gl, {\r\n        position: positions,\r\n        id: ids,\r\n        indices: indices,\r\n      });\r\n    }\r\n\r\n\r\n    var segments = 20;\r\n    var cyAcross = 12;\r\n    var cyDown = 25;\r\n    var bufferInfo = twgl.primitives.createCubeBufferInfo(gl, 2);\r\n    var screenBufferInfo = createUnitQuadsBufferInfo(gl, segments, 1);\r\n\r\n    var fbSize = 1024;\r\n    var framebufferInfo = twgl.createFramebufferInfo(gl, undefined, fbSize, fbSize);\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var uniforms = {\r\n      u_lightWorldPos: [1, 8, -10],\r\n      u_lightColor: [0.2, 0.5, 1.0, 1],\r\n      u_ambient: [0, 0, 0, 1],\r\n      u_specular: [1, 1, 1, 1],\r\n      u_shininess: 50,\r\n      u_specularFactor: 1,\r\n      u_diffuse: tex,\r\n      u_fogColor: [1, 1, 1, 1],\r\n      u_fogNear: 5,\r\n      u_fogFar: 25,\r\n      u_world: m4.identity(),\r\n    };\r\n\r\n    var screenUniforms = {\r\n      u_texture: framebufferInfo.attachments[0],\r\n      u_matrix: m4.translation([1, 1, 0]),\r\n      u_projection: m4.identity(),\r\n      u_angleTime: 0,\r\n      u_angleScale: 1,\r\n    };\r\n\r\n    function lerp(a, b, t) {\r\n      return a + (b - a) * t;\r\n    }\r\n\r\n    var useFramebuffer = true;\r\n\r\n    function switchMode() {\r\n      useFramebuffer = !useFramebuffer;\r\n    }\r\n\r\n    window.addEventListener('keypress', switchMode, false);\r\n    window.addEventListener('click', switchMode, false);\r\n    window.addEventListener('touchstart', switchMode, false);\r\n\r\n    var currentBaseColor;\r\n    var targetBaseColor;\r\n    var baseColorScale;\r\n    var colorFadeDuration = 5;\r\n    var colorChangeDuration = 10;\r\n    var colorFadeTimer;\r\n    var colorChangeTimer;\r\n\r\n    function pickNewColor() {\r\n      currentBaseColor = targetBaseColor || chroma.hsv(Math.random() * 360, 1, 1);\r\n      targetBaseColor = chroma.hsv(Math.random() * 360, 1, 1);\r\n      baseColorScale = chroma.scale([currentBaseColor, targetBaseColor]).mode('lab');\r\n      colorFadeTimer = colorFadeDuration;\r\n      colorChangeTimer = colorChangeDuration;\r\n    }\r\n    pickNewColor();\r\n\r\n    var then = 0;\r\n    function render(time) {\r\n      time *= 0.001;\r\n      var deltaTime = time - then;\r\n      then = time;\r\n\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n\r\n      var aspect;\r\n      if (useFramebuffer) {\r\n        twgl.bindFramebufferInfo(gl, framebufferInfo);\r\n        aspect = 1;\r\n      } else {\r\n        twgl.bindFramebufferInfo(gl, null);\r\n        aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      }\r\n\r\n      colorFadeTimer -= deltaTime;\r\n      colorChangeTimer -= deltaTime;\r\n      if (colorChangeTimer <= 0) {\r\n        pickNewColor();\r\n      }\r\n\r\n      var colorLerp = 1 - Math.max(0, colorFadeTimer / colorFadeDuration);\r\n      var fadeColor = baseColorScale(colorLerp);\r\n      uniforms.u_fogColor = fadeColor.gl();\r\n      var fc = uniforms.u_fogColor;\r\n\r\n      gl.cullFace(gl.BACK);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clearColor(fc[0], fc[1], fc[2], fc[3]);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, aspect, 0.5, 30);\r\n      var eye = [1, 0, -16];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      var camera = m4.lookAt(eye, target, up);\r\n      var view = m4.inverse(camera);\r\n      var viewProjection = m4.multiply(projection, view);\r\n      uniforms.u_viewInverse = camera;\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      for (var ii = 0; ii < 25; ++ii) {\r\n        var x = ii % 5;\r\n        var y = ii / 5 | 0;\r\n        var world = uniforms.u_world;\r\n        m4.identity(world);\r\n        m4.translate(world, [0, 0, 0], world);\r\n        m4.rotateY(world, time * 0.43, world);\r\n        m4.rotateZ(world, time * 0.37, world);\r\n        m4.translate(world, [x * 3 - 7 - 3, y * 3 - 5 - 3, 0], world);\r\n        m4.rotateX(world, time * 0.21 + ii, world);\r\n        m4.rotateY(world, time * 0.53 + ii, world);\r\n\r\n        uniforms.u_world = world;\r\n        uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(world));\r\n        uniforms.u_worldViewProjection = m4.multiply(viewProjection, world);\r\n//        uniforms.u_lightColor[0] = x / 4;\r\n//        uniforms.u_lightColor[1] = y / 4;\r\n//        uniforms.u_lightColor[2] = 1 - (x + y) / 8;\r\n\r\n//        uniforms.u_lightColor[0] = Math.max(x, y) / 5;\r\n//        uniforms.u_lightColor[1] = Math.max(y, x) / 5;\r\n//        uniforms.u_lightColor[2] = 1;// - (x + y) / 8;\r\n        uniforms.u_lightColor = [2, 2, 2, 1];\r\n\r\n        twgl.setUniforms(programInfo, uniforms);\r\n        twgl.drawBufferInfo(gl, bufferInfo);\r\n      }\r\n\r\n      if (useFramebuffer) {\r\n        twgl.bindFramebufferInfo(gl, null);\r\n\r\n        gl.clearColor(0, 0, 0, 0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        gl.useProgram(kaleidProgramInfo.program);\r\n\r\n        var maxScale = Math.PI * 2 / 6;\r\n        var minScale = Math.PI * 2 / segments;\r\n        var s = 0.7;\r\n        aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n        m4.ortho(-aspect * s, aspect * s, -1 * s, 1 * s, -1, 1, screenUniforms.u_projection);\r\n        screenUniforms.u_angleTime = time * 0.1;\r\n        screenUniforms.u_angleScale = lerp(minScale, maxScale, Math.sin(time * 0.017) * 0.5 + 0.5);\r\n        m4.identity(screenUniforms.u_matrix);\r\n        m4.translate(screenUniforms.u_matrix, [1, 0.5, 0], screenUniforms.u_matrix);\r\n        m4.scale(screenUniforms.u_matrix, [1, 2, 1], screenUniforms.u_matrix);\r\n\r\n        twgl.setBuffersAndAttributes(gl, kaleidProgramInfo, screenBufferInfo);\r\n        twgl.setUniforms(kaleidProgramInfo, screenUniforms);\r\n        twgl.drawBufferInfo(gl, screenBufferInfo);\r\n      }\r\n\r\n      //requestAnimationFrame(render);\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"adapted from https://twgljs.org/ example"
 ,"usesShader": {"kaleid": {"@rid":"41:4", "@class":"shader"
, "name":"kaleid shader"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec4 a_position;\r\n    attribute vec2 a_id;\r\n    varying vec2 v_texcoord;\r\n    uniform mat4 u_matrix;\r\n    uniform mat4 u_projection;\r\n    uniform float u_angleTime;\r\n    uniform float u_angleScale;\r\n    void main() {\r\n      vec4 localPosition = u_matrix * a_position;\r\n      float angle = a_id.x * u_angleScale + u_angleTime;\r\n      float radius = localPosition.y;\r\n      float c = cos(angle);\r\n      float s = sin(angle);\r\n      mat4 m = mat4(\r\n          vec4(c, s, 0, 0),\r\n          vec4(-s, c, 0, 0),\r\n          vec4(0, 0, 1, 0),\r\n          vec4(0, 0, 0, 1));\r\n      gl_Position = u_projection * m * localPosition;\r\n      v_texcoord = a_position.xy * 0.5 + 0.5;\r\n    }"
 ,"fragmentScript":"/* Fragment Shader Fri Jan 13 21:25:42 MST 2017 by admin*/\r\n  precision mediump float;\r\n\r\n    varying vec2 v_texcoord;\r\n    uniform sampler2D u_texture;\r\n\r\n    void main() {\r\n      gl_FragColor = texture2D(u_texture, v_texcoord);\r\n    }"
 ,"testScript":"/* Shader Test Fri Jan 13 21:25:42 MST 2017 by admin*/"
 ,"description":"used by Kaleidoscope"
 ,"usesShader": {} }} },
{"@rid":"41:6", "@class":"shader"
, "name":"Zoom"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 03:16:20 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              abs(l),//max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 03:16:20 MST 2017 by admin*/\r\n  \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var v3 = twgl.v3;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var shapes = [\r\n      twgl.primitives.createCubeBufferInfo(gl, 2),\r\n      twgl.primitives.createSphereBufferInfo(gl, 1, 24, 12),\r\n      twgl.primitives.createTruncatedConeBufferInfo(gl, 1, 0, 2, 24, 1),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    function easeInOut(t, start, end) {\r\n      var c = end - start;\r\n      if ((t /= 0.5) < 1) {\r\n        return c / 2 * t * t + start;\r\n      } else {\r\n        return -c / 2 * ((--t) * (t - 2) - 1) + start;\r\n      }\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n    var targetNdx = 0;\r\n    var targetTimer = 0;\r\n    var zoomTimer = 0;\r\n    var eye = v3.copy([1, 4, -60]);\r\n    var target = v3.copy([0, 0, 0]);\r\n    var up = [0, 1, 0];\r\n    var zoomScale = 1.4;\r\n    var zoomDuration = 2;\r\n    var targetChangeInterval = 3;\r\n    var oldEye;\r\n    var oldTarget;\r\n    var newEye;\r\n    var newTarget;\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-50, 50), rand(-50, 50), rand(-50, 50)],\r\n        scale: rand(1, 5),\r\n        size: 2,\r\n        xSpeed: rand(0.2, 0.7),\r\n        zSpeed: rand(0.2, 0.7),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    var then = 0;\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      var elapsed = time - then;\r\n      then = time;\r\n\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var fovy = 30 * Math.PI / 180;\r\n      var projection = m4.perspective(fovy, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 200);\r\n\r\n      targetTimer -= elapsed;\r\n      if (targetTimer <= 0) {\r\n        targetTimer = targetChangeInterval;\r\n        zoomTimer = 0;\r\n        targetNdx = (targetNdx + 1) % objects.length;\r\n        oldEye = v3.copy(eye);\r\n        oldTarget = v3.copy(target);\r\n        var targetObj = objects[targetNdx];\r\n        newTarget = targetObj.translation;\r\n        var halfSize = targetObj.size * targetObj.scale * zoomScale * 0.5;\r\n        var distance = halfSize / Math.tan(fovy * 0.5);\r\n        var direction = v3.normalize(v3.subtract(eye, newTarget));\r\n        newEye = v3.add(newTarget, v3.mulScalar(direction, distance));\r\n      }\r\n\r\n      zoomTimer += elapsed;\r\n      var lerp = easeInOut(Math.min(1, zoomTimer / zoomDuration), 0, 1);\r\n      eye = v3.lerp(oldEye, newEye, lerp);\r\n      target = v3.lerp(oldTarget, newTarget, lerp);\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time * obj.xSpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.scale(world, [obj.scale, obj.scale, obj.scale], world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      requestAnimationFrame(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Zoom around to different objects\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} },
{"@rid":"41:7", "@class":"shader"
, "name":"Tiny"
 ,"vertexScript":"/* Vertex Shader */\r\nattribute vec4 position;\r\n\r\nvoid main() {\r\n  gl_Position = position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:12:51 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nuniform vec2 resolution;\r\nuniform float time;\r\n\r\nvoid main() {\r\n  vec2 uv = gl_FragCoord.xy / resolution;\r\n  float color = 0.0;\r\n  // lifted from glslsandbox.com\r\n  color += sin( uv.x * cos( time / 3.0 ) * 60.0 ) + cos( uv.y * cos( time / 2.80 ) * 10.0 );\r\n  color += sin( uv.y * sin( time / 2.0 ) * 40.0 ) + cos( uv.x * sin( time / 1.70 ) * 40.0 );\r\n  color += sin( uv.x * sin( time / 1.0 ) * 10.0 ) + sin( uv.y * sin( time / 3.50 ) * 80.0 );\r\n  color *= sin( time / 10.0 ) * 0.5;\r\n\r\n  gl_FragColor = vec4( vec3( color * 0.5, sin( color + time / 2.5 ) * 0.75, color ), 1.0 );\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:12:51 MST 2017 by admin*/\r\n    \"use strict\";\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var arrays = {\r\n      position: [-1, -1, 0, 1, -1, 0, -1, 1, 0, -1, 1, 0, 1, -1, 0, 1, 1, 0],\r\n    };\r\n    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\r\n\r\n    function render(time) {\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      var uniforms = {\r\n        time: time * 0.001,\r\n        resolution: [gl.canvas.width, gl.canvas.height],\r\n      };\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      twgl.setUniforms(programInfo, uniforms);\r\n      twgl.drawBufferInfo(gl, bufferInfo);\r\n\r\n      requestAnimationFrame(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Smallest, simplest shader\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} },
{"@rid":"41:8", "@class":"shader"
, "name":"Cube"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:15:05 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_ambient;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y + diffuseColor * u_ambient +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:15:05 MST 2017 by admin*/\r\n\"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var arrays = {\r\n      position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],\r\n      normal:   [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],\r\n      texcoord: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],\r\n      indices:  [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],\r\n    };\r\n    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var uniforms = {\r\n      u_lightWorldPos: [1, 8, -10],\r\n      u_lightColor: [1, 0.8, 0.8, 1],\r\n      u_ambient: [0, 0, 0, 1],\r\n      u_specular: [1, 1, 1, 1],\r\n      u_shininess: 50,\r\n      u_specularFactor: 1,\r\n      u_diffuse: tex,\r\n    };\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 10);\r\n      var eye = [1, 4, -6];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      var camera = m4.lookAt(eye, target, up);\r\n      var view = m4.inverse(camera);\r\n      var viewProjection = m4.multiply(projection, view);\r\n      var world = m4.rotationY(time);\r\n\r\n      uniforms.u_viewInverse = camera;\r\n      uniforms.u_world = world;\r\n      uniforms.u_worldInverseTranspose = m4.transpose(m4.inverse(world));\r\n      uniforms.u_worldViewProjection = m4.multiply(viewProjection, world);\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      twgl.setUniforms(programInfo, uniforms);\r\n      gl.drawElements(gl.TRIANGLES, bufferInfo.numElements, gl.UNSIGNED_SHORT, 0);\r\n\r\n      //requestAnimationFrame(render);\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Rotating Cube\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} },
{"@rid":"41:12", "@class":"shader"
, "name":"2D Lines"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_matrix;\r\nuniform vec4 u_offsets;\r\nuniform vec4 u_centers;\r\nuniform vec4 u_mult;\r\n\r\nattribute vec2 a_position;\r\nattribute vec4 a_color;\r\n\r\nvarying vec4 v_color;\r\n\r\n#define PI 3.14159\r\n\r\nvoid main() {\r\n  vec2 offset = mix(u_offsets.xz, u_offsets.yw, a_position.y);\r\n  float a = u_mult.x * a_position.x * PI * 2.0 + offset.x;//mix(u_offsets.x, u_offsets.y, a_position.y);\r\n  float c = cos(a * u_mult.y);\r\n  vec2 xy = vec2(\r\n    cos(a),\r\n    sin(a)) * c * offset.y +\r\n    mix(u_centers.xy, u_centers.zw, a_position.y);\r\n  gl_Position = u_matrix * vec4(xy, 0, 1);\r\n  v_color = a_color;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 14:50:25 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_color;\r\n\r\nvoid main() {\r\n  gl_FragColor = v_color;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 14:50:25 MST 2017 by admin*/\r\n    \"use strict\";\r\n    var m4 = twgl.m4;\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var numLines = 100;\r\n    var arrays = {\r\n      position: twgl.primitives.createAugmentedTypedArray(2, numLines * 2),\r\n      color: twgl.primitives.createAugmentedTypedArray(3, numLines * 2, Uint8Array),\r\n    };\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    var hue = rand(0, 360);\r\n    for (var ii = 0; ii < numLines; ++ii) {\r\n      var u = ii / numLines;\r\n      var h = (360 + hue + (Math.abs(u - 0.5) * 100)) % 360;\r\n      var s = Math.sin(u * Math.PI * 2) * 0.25 + 0.75;\r\n      var v = 1;\r\n      var color = chroma.hsv(h, s, v);\r\n      arrays.position.push(u, 1);\r\n      arrays.color.push(color.rgb());\r\n      arrays.position.push(u, 0);\r\n      arrays.color.push(color.brighten().desaturate().rgb());\r\n    }\r\n\r\n    var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);\r\n    var offsets = [0, 0, 0, 1];\r\n    var centers = [0, 0, 0, 0];\r\n    var mult =    [1, 2, 0, 0];\r\n    var uniforms = {\r\n      u_matrix: m4.identity(),\r\n      u_offsets: offsets,\r\n      u_centers: centers,\r\n      u_mult: mult,\r\n    };\r\n\r\n    function render() {\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.enable(gl.CULL_FACE);\r\n      gl.clearColor(0, 0, 0, 1);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var time = Date.now() * 0.001;\r\n\r\n      offsets[0] = Math.sin(time);\r\n      offsets[1] = Math.sin(time * 0.13) * Math.PI * 2;\r\n      offsets[2] = Math.sin(time * 0.43) * 0.5 + 1.0;\r\n      offsets[3] = Math.cos(time * 0.17) * 0.5 + 0.5;\r\n\r\n      centers[0] = Math.sin(time * 0.163) * 0.5;\r\n      centers[1] = Math.cos(time * 0.267) * 0.5;\r\n      centers[2] = Math.sin(time * 0.367) * 0.5;\r\n      centers[3] = Math.cos(time * 0.497) * 0.5;\r\n\r\n      mult[1] = (Math.sin(time * 0.1) * 0.5 + 0.5) * 3;\r\n\r\n      gl.lineWidth(2);\r\n\r\n      var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      m4.ortho(-aspect, aspect, 1, -1, -1, 1, uniforms.u_matrix);\r\n\r\n      gl.useProgram(programInfo.program);\r\n      twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);\r\n      twgl.setUniforms(programInfo, uniforms);\r\n\r\n      twgl.drawBufferInfo(gl, bufferInfo, gl.LINES);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    render();"
 ,"description":"Draw lines\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} },
{"@rid":"41:14", "@class":"shader"
, "name":"Concat"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 15:01:41 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              abs(l),//max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 15:01:41 MST 2017 by admin*/\r\n    \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    var cubeVertices = twgl.primitives.createCubeVertices(2);\r\n    var sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);\r\n    // move the sphere 2 units up\r\n    twgl.primitives.reorientVertices(\r\n        sphereVertices, twgl.m4.translation([0, 2, 0]));\r\n    // merge the sphere with the cube\r\n    var cubeSphereVertices = twgl.primitives.concatVertices(\r\n        [cubeVertices, sphereVertices]);\r\n    // turn them into WebGL buffers and attrib data\r\n    var cubeSphereBufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);\r\n\r\n    var cubeArrays = {\r\n      position: [1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1],\r\n      normal:   [1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1],\r\n      texcoord: {\r\n        type: Uint8Array,\r\n        normalize: false,\r\n        data: [1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1],\r\n      },\r\n      indices:  [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23],\r\n    };\r\n\r\n    var cubes = [];\r\n    for (var zz = 0; zz < 2; ++zz) {\r\n      for (var yy = 0; yy < 2; ++yy) {\r\n        for (var xx = 0; xx < 2; ++xx) {\r\n          cubes.push(twgl.primitives.reorientVertices(\r\n              twgl.primitives.duplicateVertices(cubeArrays), twgl.m4.translation([xx * 2.5, yy * 2.5, zz * 2.5])));\r\n        }\r\n      }\r\n    }\r\n    var cubeCubeVertices = twgl.primitives.concatVertices(cubes);\r\n    var cubeCubeBufferInfo = twgl.createBufferInfoFromArrays(gl, cubeCubeVertices);\r\n\r\n    var shapes = [\r\n      cubeSphereBufferInfo,\r\n      cubeCubeBufferInfo,\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [1, 4, -60];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"Object concatenation\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} },
{"@rid":"41:17", "@class":"shader"
, "name":"FOV checker"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_viewProjection;\r\nuniform mat4 u_world;\r\n\r\nattribute vec4 a_position;\r\n\r\nvoid main() {\r\n  gl_Position = u_viewProjection * u_world * a_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Sat Jan 14 16:21:22 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nuniform vec4 u_color;\r\n\r\nvoid main() {\r\n    gl_FragColor = u_color;\r\n}"
 ,"testScript":"/* Shader Test Sat Jan 14 16:21:22 MST 2017 by admin*/\r\n    \"use strict\";\r\n\r\n// GJI Added this to dynamically create the needed HTML elements\r\n\tvar udiv = document.createElement(\"div\");\r\n\tudiv.setAttribute(\"id\",\"u\");\r\n\r\n\tvar inpu = document.createElement(\"input\");\r\n\tinpu.setAttribute(\"id\",\"fov\");\r\n\tinpu.setAttribute(\"type\",\"range\");\r\n\tinpu.setAttribute(\"min\",1);\r\n\tinpu.setAttribute(\"max\",179);\r\n\tudiv.appendChild(inpu);\r\n\r\n\tvar utab = document.createElement(\"table\");\r\n\tfor (let nn of [\"fovy\",\"fovx\",\"badfovx\",\"width\",\"height\",\"aspect\"]) {\r\n     console.log(\"nn=\"+nn); \r\n      var row = document.createElement(\"tr\");\r\n      var label = document.createElement(\"td\");\r\n      label.appendChild(document.createTextNode(nn));\r\n      \r\n      var val = document.createElement(\"td\");\r\n      val.setAttribute(\"id\",nn);\r\n      \r\n      row.appendChild(label);\r\n      row.appendChild(val);\r\n      utab.appendChild(row);\r\n    }\r\n\tudiv.appendChild(utab);\r\n\tdocument.body.appendChild(udiv);\r\n// GJI end of added code\r\n\r\n\r\n\tvar m4 = twgl.m4;\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n    function createSphere(\r\n        gl,\r\n        radius,\r\n        subdivisionsAxis,\r\n        subdivisionsHeight,\r\n        hConnect,\r\n        vConnect,\r\n        startLatitudeInRadians,\r\n        endLatitudeInRadians,\r\n        startLongitudeInRadians,\r\n        endLongitudeInRadians) {\r\n\r\n      hConnect = hConnect === false ? false : true;\r\n      vConnect = vConnect === false ? false : true;\r\n\r\n      startLatitudeInRadians  = startLatitudeInRadians  || 0;\r\n      endLatitudeInRadians    = endLatitudeInRadians    || Math.PI;\r\n      startLongitudeInRadians = startLongitudeInRadians || 0;\r\n      endLongitudeInRadians   = endLongitudeInRadians   || Math.PI * 2;\r\n\r\n      var latRange = endLatitudeInRadians - startLatitudeInRadians;\r\n      var longRange = endLongitudeInRadians - startLongitudeInRadians;\r\n\r\n      // We are going to generate our sphere by iterating through its\r\n      // spherical coordinates and generating 2 lines for each quad on a\r\n      // ring of the sphere.\r\n      var numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);\r\n      var positions = twgl.primitives.createAugmentedTypedArray(3, numVertices);\r\n      var normals   = twgl.primitives.createAugmentedTypedArray(3, numVertices);\r\n      var texCoords = twgl.primitives.createAugmentedTypedArray(2 , numVertices);\r\n\r\n      // Generate the individual vertices in our vertex buffer.\r\n      for (var y = 0; y <= subdivisionsHeight; y++) {\r\n        for (var x = 0; x <= subdivisionsAxis; x++) {\r\n          // Generate a vertex based on its spherical coordinates\r\n          var u = x / subdivisionsAxis;\r\n          var v = y / subdivisionsHeight;\r\n          var theta = startLongitudeInRadians + longRange * u;\r\n          var phi =   startLatitudeInRadians + latRange * v;\r\n          var sinTheta = Math.sin(theta);\r\n          var cosTheta = Math.cos(theta);\r\n          var sinPhi = Math.sin(phi);\r\n          var cosPhi = Math.cos(phi);\r\n          var ux = cosTheta * sinPhi;\r\n          var uy = cosPhi;\r\n          var uz = sinTheta * sinPhi;\r\n          positions.push(radius * ux, radius * uy, radius * uz);\r\n          normals.push(ux, uy, uz);\r\n          texCoords.push(1 - u, v);\r\n        }\r\n      }\r\n\r\n      var numVertsAround = subdivisionsAxis + 1;\r\n      var linesPerQuad = (hConnect ? 1 : 0) + (vConnect ? 1 : 0);\r\n      var indices = twgl.primitives.createAugmentedTypedArray(2, subdivisionsAxis * subdivisionsHeight * linesPerQuad, Uint16Array);\r\n      for (var x = 0; x < subdivisionsAxis; x++) {  // eslint-disable-line\r\n        for (var y = 0; y < subdivisionsHeight; y++) {  // eslint-disable-line\r\n          // Make hline of quad.\r\n          if (hConnect) {\r\n            indices.push(\r\n                (y + 0) * numVertsAround + x,\r\n                (y + 0) * numVertsAround + x + 1);\r\n          }\r\n\r\n          // Make vline of quad.\r\n          if (vConnect) {\r\n            indices.push(\r\n                (y + 1) * numVertsAround + x,\r\n                (y + 0) * numVertsAround + x);\r\n          }\r\n        }\r\n      }\r\n\r\n      return twgl.createBufferInfoFromArrays(gl, {\r\n        position: positions,\r\n        normal: normals,\r\n        texcoord: texCoords,\r\n        indices: indices,\r\n      });\r\n    }\r\n\r\n    function deg2Rad(d) {\r\n      return d * Math.PI / 180;\r\n    }\r\n\r\n    function rad2Deg(r) {\r\n      return r * 180 / Math.PI;\r\n    }\r\n\r\n    var radius = 10;\r\n    var a = Math.PI * 1.5;\r\n    var b = Math.PI * 0.5;\r\n    var c = 0.01;\r\n    var vMarksSphere = createSphere(gl, radius, 2, 180, true, false, 0, Math.PI, a - c, a + c);\r\n    var hMarksSphere = createSphere(gl, radius, 360, 2, false, true, b - c, b + c, 0, Math.PI * 2);\r\n    var highDetailSphere = createSphere(gl, radius, 36 * 2, 18 * 2);\r\n    var detailSphere = createSphere(gl, radius, 36, 18);\r\n    var v3rdsSphere = createSphere(gl, radius, 12, 36, false, true);\r\n    var h3rdsSphere = createSphere(gl, radius, 36, 6, true, false);\r\n    var vQuadSphere = createSphere(gl, radius, 4, 36, false, true);\r\n    var hQuadSphere = createSphere(gl, radius, 36, 2, true, false);\r\n\r\n    /**\r\n     *   0---1\r\n     *   |   |\r\n     *   2---3\r\n     *   |   |\r\n     *   4---5\r\n     */\r\n    var numberPositions = [\r\n      -1,  1,  1,  1,\r\n      -1,  0,  1,  0,\r\n      -1, -1,  1, -1,\r\n    ];\r\n\r\n    var numberIndices = [\r\n      [ 0, 1, 1, 5, 5, 4, 4, 0 ], // 0\r\n      [ 1, 5 ],  // 1\r\n      [ 0, 1, 1, 3, 3, 2, 2, 4, 4, 5 ], // 2\r\n      [ 0, 1, 1, 5, 5, 4, 2, 3 ],       // 3\r\n      [ 0, 2, 2, 3, 1, 5 ],             // 4\r\n      [ 1, 0, 0, 2, 2, 3, 3, 5, 5, 4 ], // 5\r\n      [ 1, 0, 0, 4, 4, 5, 5, 3, 3, 2 ], // 6\r\n      [ 0, 1, 1, 5 ],                   // 7\r\n      [ 0, 1, 1, 5, 5, 4, 4, 0, 2, 3 ], // 8\r\n      [ 3, 2, 2, 0, 0, 1, 1, 5 ],       // 9\r\n    ];\r\n\r\n    var total = 0;\r\n    var numberInfos = numberIndices.map(function(indices) {\r\n      var offset = total;\r\n      var count  = indices.length;\r\n      total += count;\r\n      return {\r\n        offset: offset * 2,\r\n        count: count,\r\n      };\r\n    });\r\n\r\n    var numberBufferInfo = twgl.createBufferInfoFromArrays(gl, {\r\n      position: { numComponents: 2, data: numberPositions },\r\n      indices:  { numComponents: 2, data: Array.prototype.concat.apply([], numberIndices) },\r\n    });\r\n\r\n    var fieldOfViewY = deg2Rad(30);\r\n    var viewProjection = m4.identity();\r\n\r\n    var drawObjects = [\r\n      { programInfo: programInfo,\r\n        bufferInfo: vMarksSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0.3, 0.3, 0.3, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: hMarksSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0.3, 0.3, 0.3, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: highDetailSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0.3, 0.3, 0.3, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: detailSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0, 0, 1, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: h3rdsSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0, 1, 0, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: v3rdsSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [0, 1, 0, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: hQuadSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [1, 0, 0, 1],\r\n        },\r\n      },\r\n      { programInfo: programInfo,\r\n        bufferInfo: vQuadSphere,\r\n        type: gl.LINES,\r\n        uniforms: {\r\n          u_world: m4.identity(),\r\n          u_viewProjection: viewProjection,\r\n          u_color: [1, 0, 0, 1],\r\n        },\r\n      },\r\n    ];\r\n\r\n    function addNumber(value, world) {\r\n      var str = value.toString();\r\n      var length = str.length;\r\n      var letterSize = 2.0;\r\n      var padding = 0.6;\r\n      var scale = [0.2, 0.2, 1];\r\n      var spacing = letterSize + padding;\r\n      var xOffset = (length - 1) * (spacing) * -0.5;\r\n      Array.prototype.forEach.call(str, function(digit, ndx) {\r\n        var mat = m4.copy(world);\r\n        m4.scale(mat, scale, mat);\r\n        m4.translate(mat, [xOffset + ndx * spacing, 0, 0], mat);\r\n        var digitNdx = parseInt(digit);\r\n        var numberInfo = numberInfos[digitNdx];\r\n        drawObjects.push({\r\n          programInfo: programInfo,\r\n          bufferInfo: numberBufferInfo,\r\n          type: gl.LINES,\r\n          offset: numberInfo.offset,\r\n          count: numberInfo.count,\r\n          uniforms: {\r\n            u_world: mat,\r\n            u_viewProjection: viewProjection,\r\n            u_color: [1, 1, 1, 1],\r\n          },\r\n        });\r\n      });\r\n    }\r\n\r\n    // Add numbers around sphere\r\n    for (var ii = -180; ii < 180; ii += 10) {\r\n      var world = m4.identity();\r\n      m4.rotateY(world, deg2Rad(ii), world);\r\n      m4.translate(world, [0, 0, -radius], world);\r\n      addNumber(Math.abs(ii), world);\r\n\r\n      world = m4.identity();\r\n      m4.rotateX(world, deg2Rad(ii), world);\r\n      m4.translate(world, [0, 0, -radius], world);\r\n      addNumber(Math.abs(ii), world);\r\n    }\r\n\r\n    function render() {\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.clearColor(0, 0, 0, 1);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      gl.lineWidth(2);\r\n\r\n      var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      var zNear  = 0.1;\r\n      var zFar   = 50;\r\n      m4.perspective(fieldOfViewY, aspect, zNear, zFar, viewProjection);\r\n      //m4.translate(matrix, [0, 0, -40], matrix);\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n    }\r\n\r\n    function createTextNodeInElement(id) {\r\n      console.log(\"create text node in \"+id);\r\n      var elem = document.getElementById(id);\r\n      var node = document.createTextNode(\"\");\r\n      elem.appendChild(node);\r\n      return node;\r\n    }\r\n\r\n    function makeNodes(ids) {\r\n      var nodes = {};\r\n      ids.forEach(function(id) {\r\n        nodes[id] = createTextNodeInElement(id);\r\n      });\r\n      return nodes;\r\n    }\r\n\r\n    var rangeElem = document.getElementById(\"fov\");\r\n    var nodes = makeNodes([\"fovy\", \"fovx\", \"width\", \"height\", \"aspect\", \"badfovx\"]);\r\n    rangeElem.value = 30;\r\n\r\n    function updateNodes() {\r\n      var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\r\n      var fieldOfViewX = 2 * Math.atan(Math.tan(fieldOfViewY * 0.5) * aspect);\r\n      var badFieldOfViewX = fieldOfViewY * aspect;\r\n\r\n      nodes.fovy.nodeValue    = rad2Deg(fieldOfViewY).toFixed(2);\r\n      nodes.fovx.nodeValue    = rad2Deg(fieldOfViewX).toFixed(2);\r\n      nodes.badfovx.nodeValue = rad2Deg(badFieldOfViewX).toFixed(2);\r\n      nodes.width.nodeValue   = gl.canvas.clientWidth;\r\n      nodes.height.nodeValue  = gl.canvas.clientHeight;\r\n      nodes.aspect.nodeValue  = aspect.toFixed(3);\r\n    }\r\n    updateNodes();\r\n\r\n    function updateFOV() {\r\n      fieldOfViewY = deg2Rad(rangeElem.value);\r\n      updateNodes();\r\n      render();\r\n    }\r\n\r\n    rangeElem.addEventListener('input', updateFOV, false);\r\n    window.addEventListener('resize', updateFOV, false);\r\n\r\n    render();"
 ,"description":"Field of view display\r\nadapted from https://twgljs.org/ example"
 ,"usesShader": {} },
{"@rid":"41:22", "@class":"shader"
, "name":"Packed arrays"
 ,"vertexScript":"/* Vertex Shader */\r\nuniform mat4 u_worldViewProjection;\r\nuniform vec3 u_lightWorldPos;\r\nuniform mat4 u_world;\r\nuniform mat4 u_viewInverse;\r\nuniform mat4 u_worldInverseTranspose;\r\n\r\nattribute vec4 a_position;\r\nattribute vec3 a_normal;\r\nattribute vec2 a_texcoord;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nvoid main() {\r\n  v_texCoord = a_texcoord;\r\n  v_position = (u_worldViewProjection * a_position);\r\n  v_normal = (u_worldInverseTranspose * vec4(a_normal, 0)).xyz;\r\n  v_surfaceToLight = u_lightWorldPos - (u_world * a_position).xyz;\r\n  v_surfaceToView = (u_viewInverse[3] - (u_world * a_position)).xyz;\r\n  gl_Position = v_position;\r\n}"
 ,"fragmentScript":"/* Fragment Shader Mon Jan 16 23:58:13 MST 2017 by admin*/\r\nprecision mediump float;\r\n\r\nvarying vec4 v_position;\r\nvarying vec2 v_texCoord;\r\nvarying vec3 v_normal;\r\nvarying vec3 v_surfaceToLight;\r\nvarying vec3 v_surfaceToView;\r\n\r\nuniform vec4 u_lightColor;\r\nuniform vec4 u_diffuseMult;\r\nuniform sampler2D u_diffuse;\r\nuniform vec4 u_specular;\r\nuniform float u_shininess;\r\nuniform float u_specularFactor;\r\n\r\nvec4 lit(float l ,float h, float m) {\r\n  return vec4(1.0,\r\n              abs(l),//max(l, 0.0),\r\n              (l > 0.0) ? pow(max(0.0, h), m) : 0.0,\r\n              1.0);\r\n}\r\n\r\nvoid main() {\r\n  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord) * u_diffuseMult;\r\n  vec3 a_normal = normalize(v_normal);\r\n  vec3 surfaceToLight = normalize(v_surfaceToLight);\r\n  vec3 surfaceToView = normalize(v_surfaceToView);\r\n  vec3 halfVector = normalize(surfaceToLight + surfaceToView);\r\n  vec4 litR = lit(dot(a_normal, surfaceToLight),\r\n                    dot(a_normal, halfVector), u_shininess);\r\n  vec4 outColor = vec4((\r\n  u_lightColor * (diffuseColor * litR.y +\r\n                u_specular * litR.z * u_specularFactor)).rgb,\r\n      diffuseColor.a);\r\n  gl_FragColor = outColor;\r\n}"
 ,"testScript":"/* Shader Test Mon Jan 16 23:58:13 MST 2017 by admin*/\r\n    \"use strict\";\r\n    twgl.setDefaults({attribPrefix: \"a_\"});\r\n    var m4 = twgl.m4;\r\n    var gl = twgl.getWebGLContext(document.getElementById(\"c\"));\r\n    var programInfo = twgl.createProgramInfo(gl, [\"vs\", \"fs\"]);\r\n\r\n// ------------------------------------------------------------------\r\n// This is all the code needed to automatically pack unpacked arrays\r\n// It's not included in TWGL because packing unpacked arrays seems\r\n// like overkill. Do you really gain much? If you're really going\r\n// for perf it seems like you'd pack offline\r\n\r\n    function isArrayBuffer(a) {\r\n      return a && a.buffer && a.buffer instanceof ArrayBuffer;\r\n    }\r\n\r\n    function getGLTypeForArray(array, arrayName) {\r\n      if (isArrayBuffer(array)) {\r\n        return twgl.getGLTypeForTypedArray(array);\r\n      }\r\n\r\n      if (isArrayBuffer(array.data)) {\r\n        return twgl.getGLTypeForTypedArray(array.data);\r\n      }\r\n\r\n      var Type = array.type;\r\n      if (!Type) {\r\n        if (arrayName === \"indices\") {\r\n          Type = Uint16Array;\r\n        } else {\r\n          Type = Float32Array;\r\n        }\r\n      }\r\n      return twgl.getGLTypeForTypedArray(new Type(0));\r\n    }\r\n\r\n    function getNormalizationForGLType(gl, type) {\r\n      switch (type) {\r\n        case gl.BYTE:\r\n        case gl.UNSIGNED_BYTE:\r\n          return true;\r\n        default:\r\n          return false;\r\n      }\r\n    }\r\n\r\n    function getNumBytesForGLType(type) {\r\n      switch (type) {\r\n        case gl.BYTE:           return 1;  // eslint-disable-line\r\n        case gl.UNSIGNED_BYTE:  return 1;  // eslint-disable-line\r\n        case gl.SHORT:          return 2;  // eslint-disable-line\r\n        case gl.UNSIGNED_SHORT: return 2;  // eslint-disable-line\r\n        case gl.INT:            return 4;  // eslint-disable-line\r\n        case gl.UNSIGNED_INT:   return 4;  // eslint-disable-line\r\n        case gl.FLOAT:          return 4;  // eslint-disable-line\r\n        default:\r\n          throw \"unknown gl type\";\r\n      }\r\n    }\r\n\r\n    var defaultAttribPrefix = \"a_\";\r\n    function createPackedBufferInfoFromArrays(gl, arrays) {\r\n      // compute size of array needed and offsets\r\n      var offset      = 0;\r\n      var maxElements = 0;\r\n\r\n      var attribs = {};\r\n\r\n      Object.keys(arrays).forEach(function(arrayName) {\r\n        if (arrayName === \"indices\") {\r\n          return;\r\n        }\r\n        var array = arrays[arrayName];\r\n        var attribName = array.attrib || array.name || array.attribName || (defaultAttribPrefix + arrayName);\r\n        var glType = getGLTypeForArray(array, arrayName);\r\n        var attrib = {\r\n          numComponents: array.numComponents || array.size || guessNumComponentsFromName(arrayName),\r\n          type:          glType,\r\n          normalize:     array.normalize !== undefined ? array.normalize : getNormalizationForGLType(gl, glType),\r\n          offset:        offset,\r\n        };\r\n        attribs[attribName] = attrib;\r\n        var sizeInBytes = attrib.numComponents * getNumBytesForGLType(glType);\r\n        // should we handle padding? For example RGB8 is 3 bytes and will need padding\r\n        offset += sizeInBytes;\r\n        // should we check that all lengths are the same?\r\n        var length = array.length || array.data.length;\r\n        var numElements = length / attrib.numComponents;\r\n        maxElements = Math.max(maxElements, numElements);\r\n      });\r\n\r\n      var stride = offset;\r\n      var arrayBuffer = new ArrayBuffer(stride * maxElements);\r\n      var buffer = gl.createBuffer();\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n\r\n      Object.keys(arrays).forEach(function(arrayName) {\r\n        if (arrayName === \"indices\") {\r\n          return;\r\n        }\r\n        var array = arrays[arrayName];\r\n        var attribName = array.attrib || array.name || array.attribName || (defaultAttribPrefix + arrayName);\r\n        var attrib = attribs[attribName];\r\n        attrib.buffer = buffer;\r\n        attrib.stride = stride;\r\n        var data = array.length ? array : array.data;\r\n        var length = data.length;\r\n        var numComponents = attrib.numComponents;\r\n        var numElements = length / numComponents;\r\n        var Type = twgl.getTypedArrayTypeForGLType(attrib.type);\r\n        var view = new Type(arrayBuffer, attrib.offset);\r\n        var localStride = stride / getNumBytesForGLType(attrib.type);\r\n        var offset = 0;\r\n        var index = 0;\r\n        for (var elem = 0; elem < numElements; ++elem) {\r\n          for (var component = 0; component < numComponents; ++component) {\r\n            view[offset + component] = data[index++];\r\n          }\r\n          offset += localStride;\r\n        }\r\n      });\r\n\r\n      gl.bufferData(gl.ARRAY_BUFFER, arrayBuffer, gl.STATIC_DRAW);\r\n\r\n      var bufferInfo = {\r\n        attribs: attribs,\r\n      };\r\n      var indices = arrays.indices;\r\n      if (indices) {\r\n        bufferInfo.indices = twgl.createBufferFromArray(gl, indices, \"indices\");\r\n        bufferInfo.numElements = indices.length || indices.data.length;\r\n        bufferInfo.elementType = (indices instanceof Uint32Array) ?  gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;\r\n      } else {\r\n        bufferInfo.numElements = numElements;\r\n      }\r\n\r\n      return bufferInfo;\r\n    }\r\n\r\n// end of packing code\r\n// -------------------------------------------------------\r\n\r\n    var shapes = [\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createCubeVertices(2)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createSphereVertices(1, 24, 12)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createPlaneVertices(2, 2)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createTruncatedConeVertices(1, 0, 2, 24, 1)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createCresentVertices(1, 1, 0.5, 0.1, 24)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createCylinderVertices(1, 2, 24, 2)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createDiscVertices(1, 24)),\r\n      createPackedBufferInfoFromArrays(gl, twgl.primitives.createTorusVertices(1, 0.4, 24, 12)),\r\n    ];\r\n\r\n    function rand(min, max) {\r\n      return min + Math.random() * (max - min);\r\n    }\r\n\r\n    // Shared values\r\n    var lightWorldPosition = [1, 8, -10];\r\n    var lightColor = [1, 1, 1, 1];\r\n    var camera = m4.identity();\r\n    var view = m4.identity();\r\n    var viewProjection = m4.identity();\r\n\r\n    var tex = twgl.createTexture(gl, {\r\n      min: gl.NEAREST,\r\n      mag: gl.NEAREST,\r\n      src: [\r\n        255, 255, 255, 255,\r\n        192, 192, 192, 255,\r\n        192, 192, 192, 255,\r\n        255, 255, 255, 255,\r\n      ],\r\n    });\r\n\r\n    var objects = [];\r\n    var drawObjects = [];\r\n    var numObjects = 100;\r\n    var baseHue = rand(0, 360);\r\n    for (var ii = 0; ii < numObjects; ++ii) {\r\n      var uniforms = {\r\n        u_lightWorldPos: lightWorldPosition,\r\n        u_lightColor: lightColor,\r\n        u_diffuseMult: chroma.hsv((baseHue + rand(0, 60)) % 360, 0.4, 0.8).gl(),\r\n        u_specular: [1, 1, 1, 1],\r\n        u_shininess: 50,\r\n        u_specularFactor: 1,\r\n        u_diffuse: tex,\r\n        u_viewInverse: camera,\r\n        u_world: m4.identity(),\r\n        u_worldInverseTranspose: m4.identity(),\r\n        u_worldViewProjection: m4.identity(),\r\n      };\r\n      drawObjects.push({\r\n        programInfo: programInfo,\r\n        bufferInfo: shapes[ii % shapes.length],\r\n        uniforms: uniforms,\r\n      });\r\n      objects.push({\r\n        translation: [rand(-10, 10), rand(-10, 10), rand(-10, 10)],\r\n        ySpeed: rand(0.1, 0.3),\r\n        zSpeed: rand(0.1, 0.3),\r\n        uniforms: uniforms,\r\n      });\r\n    }\r\n\r\n    function render(time) {\r\n      time *= 0.001;\r\n      twgl.resizeCanvasToDisplaySize(gl.canvas);\r\n      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\r\n\r\n      gl.enable(gl.DEPTH_TEST);\r\n      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n      var projection = m4.perspective(30 * Math.PI / 180, gl.canvas.clientWidth / gl.canvas.clientHeight, 0.5, 100);\r\n      var eye = [1, 4, -40];\r\n      var target = [0, 0, 0];\r\n      var up = [0, 1, 0];\r\n\r\n      m4.lookAt(eye, target, up, camera);\r\n      m4.inverse(camera, view);\r\n      m4.multiply(projection, view, viewProjection);\r\n\r\n      objects.forEach(function(obj) {\r\n        var uni = obj.uniforms;\r\n        var world = uni.u_world;\r\n        m4.identity(world);\r\n        m4.rotateY(world, time * obj.ySpeed, world);\r\n        m4.rotateZ(world, time * obj.zSpeed, world);\r\n        m4.translate(world, obj.translation, world);\r\n        m4.rotateX(world, time, world);\r\n        m4.transpose(m4.inverse(world, uni.u_worldInverseTranspose), uni.u_worldInverseTranspose);\r\n        m4.multiply(viewProjection, uni.u_world, uni.u_worldViewProjection);\r\n      });\r\n\r\n      twgl.drawObjectList(gl, drawObjects);\r\n\r\n      SHADER_CONTROLS(render);\r\n    }\r\n    requestAnimationFrame(render);"
 ,"description":"adapted from https://twgljs.org/ example"
 ,"usesShader": {} }
] }
